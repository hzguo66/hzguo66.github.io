<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/08/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>test_post</title>
    <url>/2023/12/18/test-post/</url>
    <content><![CDATA[<h1 id="title1"><a href="#title1" class="headerlink" title="title1"></a>title1</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import title</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>tag1</tag>
        <tag>tag2</tag>
        <tag>tag3</tag>
      </tags>
  </entry>
  <entry>
    <title>信息系统分析与设计初学笔记</title>
    <url>/2024/01/06/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Gondon B.Davis: 是一个利用计算机硬件和软件，手工作业，分析，计划，控制和决策模型以及数据库的人机系统，它能提供信息，支持企业或组织的运行、管理和决策功能。</p>
<p>信息系统：是结合管理理论和方法，应用信息技术解决管理问题，为管理决策提供支持的系统。</p>
<img src="/2024/01/06/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/bff77e09788f25dc146d3fc63bf302d-1704512878778-3.jpg" class="" title="bff77e09788f25dc146d3fc63bf302d">

<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>信息系统具有数据的采集和输入、传输、存储、处理、输出等基本功能。</p>
<h2 id="信息系统的结构"><a href="#信息系统的结构" class="headerlink" title="信息系统的结构"></a>信息系统的结构</h2><h3 id="概念结构"><a href="#概念结构" class="headerlink" title="概念结构"></a>概念结构</h3><img src="/2024/01/06/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/image-20240106093835136.png" class="" title="image-20240106093835136">



<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>拆分子系统并提供该子系统功能对应的信息</p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>集中式： 主机-终端（host-terminal）系统</p>
<p>分布式：文件服务器，传统客户机-服务器（client-server，C&#x2F;S），浏览器-服务器（browser&#x2F;server，B&#x2F;S），服务器集群，云计算</p>
<h2 id="信息系统的分类"><a href="#信息系统的分类" class="headerlink" title="信息系统的分类"></a>信息系统的分类</h2><p>按照技术发展来对信息系统进行分类结合了时间和技术两个维度，一般认为信息系统的发展已经经历了数据处理系统、管理信息系统、决策支持系统、主管支持系统、商务智能系统、人工智能系统六个阶段。（P37）</p>
<p>由以上介绍可知，信息系统的技术是从解决结构化问题逐步向解决半结构化和非结构化问题发展的。</p>
<h2 id="信息系统与组织"><a href="#信息系统与组织" class="headerlink" title="信息系统与组织"></a>信息系统与组织</h2><p>信息、管理和信息系统三者的关系可以这样理解：信息是主体，管理是目的，信息系统是手段。信息、管理和信息系统三者的关系可以这样理解：信息反应了组织内部和外部相关组织的各种资源、关系和活动状态；管理是组织利用信息从事协调、控制以达成组织目标的活动过程；信息系统是对组织管理职能的技术支持系统</p>
]]></content>
      <tags>
        <tag>信息系统</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程入门</title>
    <url>/2023/12/27/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h1><p>维基百科定义：函数式编程是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算是该语言最重要的基础。而且<strong>λ演算</strong>的函数可以接受函数作为输入的参数和输出的返回值。</p>
<h1 id="学习思路"><a href="#学习思路" class="headerlink" title="学习思路"></a>学习思路</h1><ol>
<li>通过<a href="https://docs.scala-lang.org/zh-cn/scala3/book/fp-intro.html">函数式编程 | Scala 3 — Book | Scala Documentation (scala-lang.org)</a> 学习基本的函数式编程思想</li>
<li>通过 <a href="https://www.lumin.tech/articles/lambda-calculus/">何为 λ 演算 (Lambda Calculus) &#x2F;&#x2F; 圆方 (lumin.tech)</a> 理解什么是函数式编程和lambda演算</li>
<li>通过课程 <a href="https://github.com/vasnake/Principles-of-Reactive-Programming?tab=readme-ov-file">vasnake&#x2F;Principles-of-Reactive-Programming: Principles of Reactive Programming, Scala: assignments and other code from Coursera https://class.coursera.org/reactive-002 (github.com)</a> ，<a href="https://www.bilibili.com/video/BV12J41187dY?p=6&vd_source=55460d497036dd635125163b0e99f789">B站视频</a>学习monad</li>
<li><a href="https://blog.cassite.net/2018/10/06/monad-from-scratch/">从零认识 Monad | wkgcass.blogs (cassite.net)</a></li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li>什么是 <code>IO Monad </code> 来处理输入和输出???<br><a href="https://www.adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html#monads">Functors, Applicatives, And Monads In Pictures - adit.io</a></li>
<li>λ 演算中<code>高阶函数</code>、<code>柯里化</code></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><p><a href="https://docs.scala-lang.org/zh-cn/scala3/book/fp-pure-functions.html">纯函数 | Scala 3 — Book | Scala Documentation (scala-lang.org)</a></p>
</li>
<li><p><a href="https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html">深入理解函数式编程（上） - 美团技术团队 (meituan.com)</a></p>
</li>
<li><p><a href="https://www.lumin.tech/articles/lambda-calculus/">何为 λ 演算 (Lambda Calculus) &#x2F;&#x2F; 圆方 (lumin.tech)</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>test_post_image</title>
    <url>/2023/12/18/test-post-image/</url>
    <content><![CDATA[<img src="/2023/12/18/test-post-image/image-20231218222304297.png" class="" title="image-20231218222304297">

<img src="/2023/12/18/test-post-image/RE4wppa.jpg" class="" title="RE4wppa">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"> * contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"> * this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"> * The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"> * (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"> * the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.apache.flink.streaming.api.environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.annotation.Experimental;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.annotation.Internal;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.annotation.Public;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.annotation.PublicEvolving;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.ExecutionConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.InvalidProgramException;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.JobExecutionResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.RuntimeExecutionMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.cache.DistributedCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.InvalidTypesException;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.io.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.io.FilePathFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.io.InputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.restartstrategy.RestartStrategies;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.BasicTypeInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.TypeInformation;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.connector.source.Boundedness;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.connector.source.Source;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.connector.source.lib.NumberSequenceSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.dag.Transformation;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.ClosureCleaner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.Utils;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.io.TextInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple3;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.typeutils.MissingTypeInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.typeutils.PojoTypeInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.typeutils.ResultTypeQueryable;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.typeutils.TypeExtractor;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.CoreOptions;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.DeploymentOptions;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.ExecutionOptions;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.PipelineOptions;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.ReadableConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.RestOptions;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.DefaultExecutorServiceLoader;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.DetachedJobExecutionResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.JobClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.JobListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.PipelineExecutor;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.PipelineExecutorFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.PipelineExecutorServiceLoader;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.runtime.state.KeyGroupRangeAssignment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.runtime.state.StateBackend;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.runtime.state.StateBackendLoader;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.CheckpointingMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.TimeCharacteristic;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.ContinuousFileMonitoringFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.ContinuousFileReaderOperatorFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.FileMonitoringFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.FileProcessingMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.FileReadFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.FromElementsFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.FromIteratorFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.FromSplittableIteratorFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.InputFormatSourceFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.ParallelSourceFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.SocketTextStreamFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.SourceFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.StatefulSequenceSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.TimestampedFileInputSplit;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.graph.StreamGraph;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.graph.StreamGraphGenerator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.operators.StreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.DynamicCodeLoadingException;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.ExceptionUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.FlinkException;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.InstantiationUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Preconditions;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.SplittableIterator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.WrappingRuntimeException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Serializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.flink.util.Preconditions.checkNotNull;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The StreamExecutionEnvironment is the context in which a streaming program is executed. A &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * LocalStreamEnvironment&#125; will cause execution in the current JVM, a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * RemoteStreamEnvironment&#125; will cause execution on a remote setup.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The environment provides methods to control the job execution (such as setting the parallelism</span></span><br><span class="line"><span class="comment"> * or the fault tolerance/checkpointing parameters) and to interact with the outside world (data</span></span><br><span class="line"><span class="comment"> * access).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.apache.flink.streaming.api.environment.LocalStreamEnvironment</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.apache.flink.streaming.api.environment.RemoteStreamEnvironment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExecutionEnvironment</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The default name to use for a streaming job if no other name has been specified. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_JOB_NAME</span> <span class="operator">=</span> <span class="string">&quot;Flink Streaming Job&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The time characteristic that is used if none other is set. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">TimeCharacteristic</span> <span class="variable">DEFAULT_TIME_CHARACTERISTIC</span> <span class="operator">=</span></span><br><span class="line">            TimeCharacteristic.EventTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The environment of the context (local by default, cluster if invoked through command line).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StreamExecutionEnvironmentFactory</span> <span class="variable">contextEnvironmentFactory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The ThreadLocal used to store &#123;<span class="doctag">@link</span> StreamExecutionEnvironmentFactory&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;StreamExecutionEnvironmentFactory&gt;</span><br><span class="line">            threadLocalContextEnvironmentFactory = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The default parallelism used when creating a local environment. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">defaultLocalParallelism</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The execution configuration for this environment. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutionConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutionConfig</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Settings that control the checkpointing behavior. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">CheckpointConfig</span> <span class="variable">checkpointCfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckpointConfig</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;Transformation&lt;?&gt;&gt; transformations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">bufferTimeout</span> <span class="operator">=</span> ExecutionOptions.BUFFER_TIMEOUT.defaultValue().toMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="variable">isChainingEnabled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The state backend used for storing k/v state and state snapshots. */</span></span><br><span class="line">    <span class="keyword">private</span> StateBackend defaultStateBackend;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The default savepoint directory used by the job. */</span></span><br><span class="line">    <span class="keyword">private</span> Path defaultSavepointDirectory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The time characteristic used by the data streams. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TimeCharacteristic</span> <span class="variable">timeCharacteristic</span> <span class="operator">=</span> DEFAULT_TIME_CHARACTERISTIC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;Tuple2&lt;String, DistributedCache.DistributedCacheEntry&gt;&gt; cacheFile =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PipelineExecutorServiceLoader executorServiceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader userClassloader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;JobListener&gt; jobListeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Constructor and Properties</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamExecutionEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">        <span class="comment">// unfortunately, StreamExecutionEnvironment always (implicitly) had a public constructor.</span></span><br><span class="line">        <span class="comment">// This constructor is not useful because the execution environment cannot be used for</span></span><br><span class="line">        <span class="comment">// execution. We&#x27;re keeping this to appease the binary compatibiliy checks.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@link</span> StreamExecutionEnvironment&#125; that will use the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Configuration&#125; to configure the &#123;<span class="doctag">@link</span> PipelineExecutor&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamExecutionEnvironment</span><span class="params">(<span class="keyword">final</span> Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(configuration, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@link</span> StreamExecutionEnvironment&#125; that will use the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Configuration&#125; to configure the &#123;<span class="doctag">@link</span> PipelineExecutor&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In addition, this constructor allows specifying the user code &#123;<span class="doctag">@link</span> ClassLoader&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamExecutionEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> Configuration configuration, <span class="keyword">final</span> ClassLoader userClassloader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">DefaultExecutorServiceLoader</span>(), configuration, userClassloader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@link</span> StreamExecutionEnvironment&#125; that will use the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Configuration&#125; to configure the &#123;<span class="doctag">@link</span> PipelineExecutor&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In addition, this constructor allows specifying the &#123;<span class="doctag">@link</span> PipelineExecutorServiceLoader&#125;</span></span><br><span class="line"><span class="comment">     * and user code &#123;<span class="doctag">@link</span> ClassLoader&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamExecutionEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> PipelineExecutorServiceLoader executorServiceLoader,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> Configuration configuration,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> ClassLoader userClassloader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executorServiceLoader = checkNotNull(executorServiceLoader);</span><br><span class="line">        <span class="built_in">this</span>.configuration = <span class="keyword">new</span> <span class="title class_">Configuration</span>(checkNotNull(configuration));</span><br><span class="line">        <span class="built_in">this</span>.userClassloader =</span><br><span class="line">                userClassloader == <span class="literal">null</span> ? getClass().getClassLoader() : userClassloader;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the configuration of a job or an operator can be specified at the following places:</span></span><br><span class="line">        <span class="comment">//     i) at the operator level using e.g. parallelism using the</span></span><br><span class="line">        <span class="comment">// SingleOutputStreamOperator.setParallelism().</span></span><br><span class="line">        <span class="comment">//     ii) programmatically by using e.g. the env.setRestartStrategy() method</span></span><br><span class="line">        <span class="comment">//     iii) in the configuration passed here</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// if specified in multiple places, the priority order is the above.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Given this, it is safe to overwrite the execution config default values here because all</span></span><br><span class="line">        <span class="comment">// other ways assume</span></span><br><span class="line">        <span class="comment">// that the env is already instantiated so they will overwrite the value passed here.</span></span><br><span class="line">        <span class="built_in">this</span>.configure(<span class="built_in">this</span>.configuration, <span class="built_in">this</span>.userClassloader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Configuration <span class="title function_">getConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ClassLoader <span class="title function_">getUserClassloader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userClassloader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Gets the config object. */</span></span><br><span class="line">    <span class="keyword">public</span> ExecutionConfig <span class="title function_">getConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the list of cached files that were registered for distribution among the task managers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Tuple2&lt;String, DistributedCache.DistributedCacheEntry&gt;&gt; getCachedFiles() &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Gets the config JobListeners. */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;JobListener&gt; <span class="title function_">getJobListeners</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jobListeners;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the parallelism for operations executed through this environment. Setting a parallelism</span></span><br><span class="line"><span class="comment">     * of x here will cause all operators (such as map, batchReduce) to run with x parallel</span></span><br><span class="line"><span class="comment">     * instances. This method overrides the default parallelism for this environment. The &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * LocalStreamEnvironment&#125; uses by default a value equal to the number of hardware contexts (CPU</span></span><br><span class="line"><span class="comment">     * cores / threads). When executing the program via the command line client from a JAR file, the</span></span><br><span class="line"><span class="comment">     * default degree of parallelism is the one configured for that setup.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parallelism The parallelism</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setParallelism</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;</span><br><span class="line">        config.setParallelism(parallelism);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the runtime execution mode for the application (see &#123;<span class="doctag">@link</span> RuntimeExecutionMode&#125;). This</span></span><br><span class="line"><span class="comment">     * is equivalent to setting the &#123;<span class="doctag">@code</span> execution.runtime-mode&#125; in your application&#x27;s</span></span><br><span class="line"><span class="comment">     * configuration file.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;We recommend users to NOT use this method but set the &#123;<span class="doctag">@code</span> execution.runtime-mode&#125; using</span></span><br><span class="line"><span class="comment">     * the command-line when submitting the application. Keeping the application code</span></span><br><span class="line"><span class="comment">     * configuration-free allows for more flexibility as the same application will be able to be</span></span><br><span class="line"><span class="comment">     * executed in any execution mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executionMode the desired execution mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The execution environment of your application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setRuntimeMode</span><span class="params">(<span class="keyword">final</span> RuntimeExecutionMode executionMode)</span> &#123;</span><br><span class="line">        checkNotNull(executionMode);</span><br><span class="line">        configuration.set(ExecutionOptions.RUNTIME_MODE, executionMode);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the maximum degree of parallelism defined for the program. The upper limit (inclusive)</span></span><br><span class="line"><span class="comment">     * is Short.MAX_VALUE.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The maximum degree of parallelism specifies the upper limit for dynamic scaling. It also</span></span><br><span class="line"><span class="comment">     * defines the number of key groups used for partitioned state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxParallelism Maximum degree of parallelism to be used for the program., with &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     *     0 &lt; maxParallelism &lt;= 2^15 - 1&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setMaxParallelism</span><span class="params">(<span class="type">int</span> maxParallelism)</span> &#123;</span><br><span class="line">        Preconditions.checkArgument(</span><br><span class="line">                maxParallelism &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; maxParallelism &lt;= KeyGroupRangeAssignment.UPPER_BOUND_MAX_PARALLELISM,</span><br><span class="line">                <span class="string">&quot;maxParallelism is out of bounds 0 &lt; maxParallelism &lt;= &quot;</span></span><br><span class="line">                        + KeyGroupRangeAssignment.UPPER_BOUND_MAX_PARALLELISM</span><br><span class="line">                        + <span class="string">&quot;. Found: &quot;</span></span><br><span class="line">                        + maxParallelism);</span><br><span class="line"></span><br><span class="line">        config.setMaxParallelism(maxParallelism);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the parallelism with which operation are executed by default. Operations can</span></span><br><span class="line"><span class="comment">     * individually override this value to use a specific parallelism.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The parallelism used by operations, unless they override that value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getParallelism</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config.getParallelism();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the maximum degree of parallelism defined for the program.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The maximum degree of parallelism specifies the upper limit for dynamic scaling. It also</span></span><br><span class="line"><span class="comment">     * defines the number of key groups used for partitioned state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Maximum degree of parallelism</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxParallelism</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config.getMaxParallelism();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the maximum time frequency (milliseconds) for the flushing of the output buffers. By</span></span><br><span class="line"><span class="comment">     * default the output buffers flush frequently to provide low latency and to aid smooth</span></span><br><span class="line"><span class="comment">     * developer experience. Setting the parameter can result in three logical modes:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;A positive integer triggers flushing periodically by that integer</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;0 triggers flushing after every record thus minimizing latency</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;-1 triggers flushing only when the output buffer is full thus maximizing throughput</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutMillis The maximum time between two output flushes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setBufferTimeout</span><span class="params">(<span class="type">long</span> timeoutMillis)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeoutMillis &lt; ExecutionOptions.DISABLED_NETWORK_BUFFER_TIMEOUT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Timeout of buffer must be non-negative or -1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.bufferTimeout = timeoutMillis;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the maximum time frequency (milliseconds) for the flushing of the output buffers. For</span></span><br><span class="line"><span class="comment">     * clarification on the extremal values see &#123;<span class="doctag">@link</span> #setBufferTimeout(long)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The timeout of the buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getBufferTimeout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bufferTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Disables operator chaining for streaming operators. Operator chaining allows non-shuffle</span></span><br><span class="line"><span class="comment">     * operations to be co-located in the same thread fully avoiding serialization and</span></span><br><span class="line"><span class="comment">     * de-serialization.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> StreamExecutionEnvironment with chaining disabled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">disableOperatorChaining</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isChainingEnabled = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns whether operator chaining is enabled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if chaining is enabled, false otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChainingEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isChainingEnabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Checkpointing Settings</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the checkpoint config, which defines values like checkpoint interval, delay between</span></span><br><span class="line"><span class="comment">     * checkpoints, etc.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The checkpoint config.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> CheckpointConfig <span class="title function_">getCheckpointConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkpointCfg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enables checkpointing for the streaming job. The distributed state of the streaming dataflow</span></span><br><span class="line"><span class="comment">     * will be periodically snapshotted. In case of a failure, the streaming dataflow will be</span></span><br><span class="line"><span class="comment">     * restarted from the latest completed checkpoint. This method selects &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * CheckpointingMode#EXACTLY_ONCE&#125; guarantees.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The job draws checkpoints periodically, in the given interval. The state will be stored in</span></span><br><span class="line"><span class="comment">     * the configured state backend.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;<span class="doctag">NOTE:</span> Checkpointing iterative streaming dataflows in not properly supported at the moment.</span></span><br><span class="line"><span class="comment">     * For that reason, iterative jobs will not be started if used with enabled checkpointing. To</span></span><br><span class="line"><span class="comment">     * override this mechanism, use the &#123;<span class="doctag">@link</span> #enableCheckpointing(long, CheckpointingMode,</span></span><br><span class="line"><span class="comment">     * boolean)&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval Time interval between state checkpoints in milliseconds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">enableCheckpointing</span><span class="params">(<span class="type">long</span> interval)</span> &#123;</span><br><span class="line">        checkpointCfg.setCheckpointInterval(interval);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enables checkpointing for the streaming job. The distributed state of the streaming dataflow</span></span><br><span class="line"><span class="comment">     * will be periodically snapshotted. In case of a failure, the streaming dataflow will be</span></span><br><span class="line"><span class="comment">     * restarted from the latest completed checkpoint.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The job draws checkpoints periodically, in the given interval. The system uses the given</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> CheckpointingMode&#125; for the checkpointing (&quot;exactly once&quot; vs &quot;at least once&quot;). The</span></span><br><span class="line"><span class="comment">     * state will be stored in the configured state backend.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;<span class="doctag">NOTE:</span> Checkpointing iterative streaming dataflows in not properly supported at the moment.</span></span><br><span class="line"><span class="comment">     * For that reason, iterative jobs will not be started if used with enabled checkpointing. To</span></span><br><span class="line"><span class="comment">     * override this mechanism, use the &#123;<span class="doctag">@link</span> #enableCheckpointing(long, CheckpointingMode,</span></span><br><span class="line"><span class="comment">     * boolean)&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval Time interval between state checkpoints in milliseconds.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode The checkpointing mode, selecting between &quot;exactly once&quot; and &quot;at least once&quot;</span></span><br><span class="line"><span class="comment">     *     guaranteed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">enableCheckpointing</span><span class="params">(<span class="type">long</span> interval, CheckpointingMode mode)</span> &#123;</span><br><span class="line">        checkpointCfg.setCheckpointingMode(mode);</span><br><span class="line">        checkpointCfg.setCheckpointInterval(interval);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enables checkpointing for the streaming job. The distributed state of the streaming dataflow</span></span><br><span class="line"><span class="comment">     * will be periodically snapshotted. In case of a failure, the streaming dataflow will be</span></span><br><span class="line"><span class="comment">     * restarted from the latest completed checkpoint.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The job draws checkpoints periodically, in the given interval. The state will be stored in</span></span><br><span class="line"><span class="comment">     * the configured state backend.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;<span class="doctag">NOTE:</span> Checkpointing iterative streaming dataflows in not properly supported at the moment.</span></span><br><span class="line"><span class="comment">     * If the &quot;force&quot; parameter is set to true, the system will execute the job nonetheless.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval Time interval between state checkpoints in millis.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode The checkpointing mode, selecting between &quot;exactly once&quot; and &quot;at least once&quot;</span></span><br><span class="line"><span class="comment">     *     guaranteed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> force If true checkpointing will be enabled for iterative jobs as well.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #enableCheckpointing(long, CheckpointingMode)&#125; instead. Forcing</span></span><br><span class="line"><span class="comment">     *     checkpoints will be removed in the future.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">enableCheckpointing</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="type">long</span> interval, CheckpointingMode mode, <span class="type">boolean</span> force)</span> &#123;</span><br><span class="line">        checkpointCfg.setCheckpointingMode(mode);</span><br><span class="line">        checkpointCfg.setCheckpointInterval(interval);</span><br><span class="line">        checkpointCfg.setForceCheckpointing(force);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enables checkpointing for the streaming job. The distributed state of the streaming dataflow</span></span><br><span class="line"><span class="comment">     * will be periodically snapshotted. In case of a failure, the streaming dataflow will be</span></span><br><span class="line"><span class="comment">     * restarted from the latest completed checkpoint. This method selects &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * CheckpointingMode#EXACTLY_ONCE&#125; guarantees.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The job draws checkpoints periodically, in the default interval. The state will be stored</span></span><br><span class="line"><span class="comment">     * in the configured state backend.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;<span class="doctag">NOTE:</span> Checkpointing iterative streaming dataflows in not properly supported at the moment.</span></span><br><span class="line"><span class="comment">     * For that reason, iterative jobs will not be started if used with enabled checkpointing. To</span></span><br><span class="line"><span class="comment">     * override this mechanism, use the &#123;<span class="doctag">@link</span> #enableCheckpointing(long, CheckpointingMode,</span></span><br><span class="line"><span class="comment">     * boolean)&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #enableCheckpointing(long)&#125; instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">enableCheckpointing</span><span class="params">()</span> &#123;</span><br><span class="line">        checkpointCfg.setCheckpointInterval(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the checkpointing interval or -1 if checkpointing is disabled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Shorthand for &#123;<span class="doctag">@code</span> getCheckpointConfig().getCheckpointInterval()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The checkpointing interval or -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCheckpointInterval</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkpointCfg.getCheckpointInterval();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns whether checkpointing is force-enabled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Forcing checkpoints will be removed in future version.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isForceCheckpointing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkpointCfg.isForceCheckpointing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether unaligned checkpoints are enabled. */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUnalignedCheckpointsEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkpointCfg.isUnalignedCheckpointsEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether unaligned checkpoints are force-enabled. */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isForceUnalignedCheckpoints</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkpointCfg.isForceUnalignedCheckpoints();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the checkpointing mode (exactly-once vs. at-least-once).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Shorthand for &#123;<span class="doctag">@code</span> getCheckpointConfig().getCheckpointingMode()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The checkpoint mode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> CheckpointingMode <span class="title function_">getCheckpointingMode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkpointCfg.getCheckpointingMode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the state backend that describes how to store operator. It defines the data structures</span></span><br><span class="line"><span class="comment">     * that hold state during execution (for example hash tables, RocksDB, or other data stores).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;State managed by the state backend includes both keyed state that is accessible on &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.streaming.api.datastream.KeyedStream keyed streams&#125;, as well as state</span></span><br><span class="line"><span class="comment">     * maintained directly by the user code that implements &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.streaming.api.checkpoint.CheckpointedFunction CheckpointedFunction&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The &#123;<span class="doctag">@link</span> org.apache.flink.runtime.state.hashmap.HashMapStateBackend&#125; maintains state in</span></span><br><span class="line"><span class="comment">     * heap memory, as objects. It is lightweight without extra dependencies, but is limited to JVM</span></span><br><span class="line"><span class="comment">     * heap memory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In contrast, the &#123;<span class="doctag">@code</span> EmbeddedRocksDBStateBackend&#125; stores its state in an embedded</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> RocksDB&#125; instance. This state backend can store very large state that exceeds memory</span></span><br><span class="line"><span class="comment">     * and spills to local disk. All key/value state (including windows) is stored in the key/value</span></span><br><span class="line"><span class="comment">     * index of RocksDB.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In both cases, fault tolerance is managed via the jobs &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.runtime.state.CheckpointStorage&#125; which configures how and where state</span></span><br><span class="line"><span class="comment">     * backends persist during a checkpoint.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> This StreamExecutionEnvironment itself, to allow chaining of function calls.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getStateBackend()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> CheckpointConfig#setCheckpointStorage( org.apache.flink.runtime.state.CheckpointStorage)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setStateBackend</span><span class="params">(StateBackend backend)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.defaultStateBackend = Preconditions.checkNotNull(backend);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the state backend that defines how to store and checkpoint state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setStateBackend(StateBackend)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StateBackend <span class="title function_">getStateBackend</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultStateBackend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the default savepoint directory, where savepoints will be written to if no is explicitly</span></span><br><span class="line"><span class="comment">     * provided when triggered.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> This StreamExecutionEnvironment itself, to allow chaining of function calls.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getDefaultSavepointDirectory()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setDefaultSavepointDirectory</span><span class="params">(String savepointDirectory)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(savepointDirectory);</span><br><span class="line">        <span class="keyword">return</span> setDefaultSavepointDirectory(<span class="keyword">new</span> <span class="title class_">Path</span>(savepointDirectory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the default savepoint directory, where savepoints will be written to if no is explicitly</span></span><br><span class="line"><span class="comment">     * provided when triggered.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> This StreamExecutionEnvironment itself, to allow chaining of function calls.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getDefaultSavepointDirectory()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setDefaultSavepointDirectory</span><span class="params">(URI savepointDirectory)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(savepointDirectory);</span><br><span class="line">        <span class="keyword">return</span> setDefaultSavepointDirectory(<span class="keyword">new</span> <span class="title class_">Path</span>(savepointDirectory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the default savepoint directory, where savepoints will be written to if no is explicitly</span></span><br><span class="line"><span class="comment">     * provided when triggered.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> This StreamExecutionEnvironment itself, to allow chaining of function calls.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getDefaultSavepointDirectory()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setDefaultSavepointDirectory</span><span class="params">(Path savepointDirectory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.defaultSavepointDirectory = Preconditions.checkNotNull(savepointDirectory);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the default savepoint directory for this Job.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setDefaultSavepointDirectory(Path)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> Path <span class="title function_">getDefaultSavepointDirectory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultSavepointDirectory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the restart strategy configuration. The configuration specifies which restart strategy</span></span><br><span class="line"><span class="comment">     * will be used for the execution graph in case of a restart.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> restartStrategyConfiguration Restart strategy configuration to be set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRestartStrategy</span><span class="params">(</span></span><br><span class="line"><span class="params">            RestartStrategies.RestartStrategyConfiguration restartStrategyConfiguration)</span> &#123;</span><br><span class="line">        config.setRestartStrategy(restartStrategyConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the specified restart strategy configuration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The restart strategy configuration to be used</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> RestartStrategies.RestartStrategyConfiguration <span class="title function_">getRestartStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config.getRestartStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the number of times that failed tasks are re-executed. A value of zero effectively</span></span><br><span class="line"><span class="comment">     * disables fault tolerance. A value of &#123;<span class="doctag">@code</span> -1&#125; indicates that the system default value (as</span></span><br><span class="line"><span class="comment">     * defined in the configuration) should be used.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numberOfExecutionRetries The number of times the system will try to re-execute failed</span></span><br><span class="line"><span class="comment">     *     tasks.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> This method will be replaced by &#123;<span class="doctag">@link</span> #setRestartStrategy&#125;. The &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     RestartStrategies#fixedDelayRestart(int, Time)&#125; contains the number of execution retries.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumberOfExecutionRetries</span><span class="params">(<span class="type">int</span> numberOfExecutionRetries)</span> &#123;</span><br><span class="line">        config.setNumberOfExecutionRetries(numberOfExecutionRetries);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the number of times the system will try to re-execute failed tasks. A value of &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * -1&#125; indicates that the system default value (as defined in the configuration) should be used.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The number of times the system will try to re-execute failed tasks.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> This method will be replaced by &#123;<span class="doctag">@link</span> #getRestartStrategy&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumberOfExecutionRetries</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config.getNumberOfExecutionRetries();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Registry for types and serializers</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a new Kryo default serializer to the Runtime.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that the serializer instance must be serializable (as defined by</span></span><br><span class="line"><span class="comment">     * java.io.Serializable), because it may be distributed to the worker nodes by java</span></span><br><span class="line"><span class="comment">     * serialization.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the types serialized with the given serializer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serializer The serializer to use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Serializer</span>&lt;?&gt; &amp; Serializable&gt; <span class="keyword">void</span> <span class="title function_">addDefaultKryoSerializer</span><span class="params">(</span></span><br><span class="line"><span class="params">            Class&lt;?&gt; type, T serializer)</span> &#123;</span><br><span class="line">        config.addDefaultKryoSerializer(type, serializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a new Kryo default serializer to the Runtime.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the types serialized with the given serializer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serializerClass The class of the serializer to use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDefaultKryoSerializer</span><span class="params">(</span></span><br><span class="line"><span class="params">            Class&lt;?&gt; type, Class&lt;? extends Serializer&lt;?&gt;&gt; serializerClass)</span> &#123;</span><br><span class="line">        config.addDefaultKryoSerializer(type, serializerClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers the given type with a Kryo Serializer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that the serializer instance must be serializable (as defined by</span></span><br><span class="line"><span class="comment">     * java.io.Serializable), because it may be distributed to the worker nodes by java</span></span><br><span class="line"><span class="comment">     * serialization.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the types serialized with the given serializer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serializer The serializer to use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Serializer</span>&lt;?&gt; &amp; Serializable&gt; <span class="keyword">void</span> <span class="title function_">registerTypeWithKryoSerializer</span><span class="params">(</span></span><br><span class="line"><span class="params">            Class&lt;?&gt; type, T serializer)</span> &#123;</span><br><span class="line">        config.registerTypeWithKryoSerializer(type, serializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers the given Serializer via its class as a serializer for the given type at the</span></span><br><span class="line"><span class="comment">     * KryoSerializer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the types serialized with the given serializer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serializerClass The class of the serializer to use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerTypeWithKryoSerializer</span><span class="params">(</span></span><br><span class="line"><span class="params">            Class&lt;?&gt; type, Class&lt;? extends Serializer&gt; serializerClass)</span> &#123;</span><br><span class="line">        config.registerTypeWithKryoSerializer(type, serializerClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers the given type with the serialization stack. If the type is eventually serialized</span></span><br><span class="line"><span class="comment">     * as a POJO, then the type is registered with the POJO serializer. If the type ends up being</span></span><br><span class="line"><span class="comment">     * serialized with Kryo, then it will be registered at Kryo to make sure that only tags are</span></span><br><span class="line"><span class="comment">     * written.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the type to register.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerType</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Cannot register null type class.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;?&gt; typeInfo = TypeExtractor.createTypeInfo(type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (typeInfo <span class="keyword">instanceof</span> PojoTypeInfo) &#123;</span><br><span class="line">            config.registerPojoType(type);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            config.registerKryoType(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Time characteristic</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the time characteristic for all streams create from this environment, e.g., processing</span></span><br><span class="line"><span class="comment">     * time, event time, or ingestion time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If you set the characteristic to IngestionTime of EventTime this will set a default</span></span><br><span class="line"><span class="comment">     * watermark update interval of 200 ms. If this is not applicable for your application you</span></span><br><span class="line"><span class="comment">     * should change it using &#123;<span class="doctag">@link</span> ExecutionConfig#setAutoWatermarkInterval(long)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> characteristic The time characteristic.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> In Flink 1.12 the default stream time characteristic has been changed to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     TimeCharacteristic#EventTime&#125;, thus you don&#x27;t need to call this method for enabling</span></span><br><span class="line"><span class="comment">     *     event-time support anymore. Explicitly using processing-time windows and timers works in</span></span><br><span class="line"><span class="comment">     *     event-time mode. If you need to disable watermarks, please use &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     ExecutionConfig#setAutoWatermarkInterval(long)&#125;. If you are using &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     TimeCharacteristic#IngestionTime&#125;, please manually set an appropriate &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     WatermarkStrategy&#125;. If you are using generic &quot;time window&quot; operations (for example &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     org.apache.flink.streaming.api.datastream.KeyedStream#timeWindow(org.apache.flink.streaming.api.windowing.time.Time)&#125;</span></span><br><span class="line"><span class="comment">     *     that change behaviour based on the time characteristic, please use equivalent operations</span></span><br><span class="line"><span class="comment">     *     that explicitly specify processing time or event time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStreamTimeCharacteristic</span><span class="params">(TimeCharacteristic characteristic)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.timeCharacteristic = Preconditions.checkNotNull(characteristic);</span><br><span class="line">        <span class="keyword">if</span> (characteristic == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">            getConfig().setAutoWatermarkInterval(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getConfig().setAutoWatermarkInterval(<span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the time characteristic.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> See &#123;<span class="doctag">@link</span> #setStreamTimeCharacteristic(TimeCharacteristic)&#125; for deprecation</span></span><br><span class="line"><span class="comment">     *     notice.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> TimeCharacteristic <span class="title function_">getStreamTimeCharacteristic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> timeCharacteristic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets all relevant options contained in the &#123;<span class="doctag">@link</span> ReadableConfig&#125; such as e.g. &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * StreamPipelineOptions#TIME_CHARACTERISTIC&#125;. It will reconfigure &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * StreamExecutionEnvironment&#125;, &#123;<span class="doctag">@link</span> ExecutionConfig&#125; and &#123;<span class="doctag">@link</span> CheckpointConfig&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;It will change the value of a setting only if a corresponding option was set in the &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * configuration&#125;. If a key is not present, the current value of a field will remain untouched.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration a configuration to read the values from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader a class loader to use when loading classes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ReadableConfig configuration, ClassLoader classLoader)</span> &#123;</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(StreamPipelineOptions.TIME_CHARACTERISTIC)</span><br><span class="line">                .ifPresent(<span class="built_in">this</span>::setStreamTimeCharacteristic);</span><br><span class="line">        Optional.ofNullable(loadStateBackend(configuration, classLoader))</span><br><span class="line">                .ifPresent(<span class="built_in">this</span>::setStateBackend);</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(PipelineOptions.OPERATOR_CHAINING)</span><br><span class="line">                .ifPresent(c -&gt; <span class="built_in">this</span>.isChainingEnabled = c);</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(ExecutionOptions.BUFFER_TIMEOUT)</span><br><span class="line">                .ifPresent(t -&gt; <span class="built_in">this</span>.setBufferTimeout(t.toMillis()));</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(DeploymentOptions.JOB_LISTENERS)</span><br><span class="line">                .ifPresent(listeners -&gt; registerCustomListeners(classLoader, listeners));</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(PipelineOptions.CACHED_FILES)</span><br><span class="line">                .ifPresent(</span><br><span class="line">                        f -&gt; &#123;</span><br><span class="line">                            <span class="built_in">this</span>.cacheFile.clear();</span><br><span class="line">                            <span class="built_in">this</span>.cacheFile.addAll(DistributedCache.parseCachedFilesFromString(f));</span><br><span class="line">                        &#125;);</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(ExecutionOptions.RUNTIME_MODE)</span><br><span class="line">                .ifPresent(</span><br><span class="line">                        runtimeMode -&gt;</span><br><span class="line">                                <span class="built_in">this</span>.configuration.set(ExecutionOptions.RUNTIME_MODE, runtimeMode));</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(ExecutionOptions.SORT_INPUTS)</span><br><span class="line">                .ifPresent(</span><br><span class="line">                        sortInputs -&gt;</span><br><span class="line">                                <span class="built_in">this</span>.getConfiguration()</span><br><span class="line">                                        .set(ExecutionOptions.SORT_INPUTS, sortInputs));</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(ExecutionOptions.USE_BATCH_STATE_BACKEND)</span><br><span class="line">                .ifPresent(</span><br><span class="line">                        sortInputs -&gt;</span><br><span class="line">                                <span class="built_in">this</span>.getConfiguration()</span><br><span class="line">                                        .set(ExecutionOptions.USE_BATCH_STATE_BACKEND, sortInputs));</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(PipelineOptions.NAME)</span><br><span class="line">                .ifPresent(jobName -&gt; <span class="built_in">this</span>.getConfiguration().set(PipelineOptions.NAME, jobName));</span><br><span class="line">        config.configure(configuration, classLoader);</span><br><span class="line">        checkpointCfg.configure(configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerCustomListeners</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> ClassLoader classLoader, <span class="keyword">final</span> List&lt;String&gt; listeners)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String listener : listeners) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">JobListener</span> <span class="variable">jobListener</span> <span class="operator">=</span></span><br><span class="line">                        InstantiationUtil.instantiate(listener, JobListener.class, classLoader);</span><br><span class="line">                jobListeners.add(jobListener);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FlinkException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">WrappingRuntimeException</span>(<span class="string">&quot;Could not load JobListener : &quot;</span> + listener, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StateBackend <span class="title function_">loadStateBackend</span><span class="params">(ReadableConfig configuration, ClassLoader classLoader)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> StateBackendLoader.loadStateBackendFromConfig(configuration, classLoader, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DynamicCodeLoadingException | IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">WrappingRuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Data stream creations</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains a sequence of numbers. This is a parallel source, if</span></span><br><span class="line"><span class="comment">     * you manually set the parallelism to &#123;<span class="doctag">@code</span> 1&#125; (using &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator#setParallelism(int)&#125;)</span></span><br><span class="line"><span class="comment">     * the generated sequence of elements is in order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from The number to start at (inclusive)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to The number to stop at (inclusive)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream, containing all number in the [from, to] interval</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #fromSequence(long, long)&#125; instead to create a new data stream that</span></span><br><span class="line"><span class="comment">     *     contains &#123;<span class="doctag">@link</span> org.apache.flink.api.connector.source.lib.NumberSequenceSource&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;Long&gt; <span class="title function_">generateSequence</span><span class="params">(<span class="type">long</span> from, <span class="type">long</span> to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from &gt; to) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;Start of sequence must not be greater than the end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addSource(<span class="keyword">new</span> <span class="title class_">StatefulSequenceSource</span>(from, to), <span class="string">&quot;Sequence Source (Deprecated)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains a sequence of numbers (longs) and is useful for</span></span><br><span class="line"><span class="comment">     * testing and for cases that just need a stream of N events of any kind.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The generated source splits the sequence into as many parallel sub-sequences as there are</span></span><br><span class="line"><span class="comment">     * parallel source readers. Each sub-sequence will be produced in order. If the parallelism is</span></span><br><span class="line"><span class="comment">     * limited to one, the source will produce one sequence in order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This source is always bounded. For very long sequences (for example over the entire domain</span></span><br><span class="line"><span class="comment">     * of long integer values), you may consider executing the application in a streaming manner</span></span><br><span class="line"><span class="comment">     * because of the end bound that is pretty far away.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Use &#123;<span class="doctag">@link</span> #fromSource(Source, WatermarkStrategy, String)&#125; together with &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * NumberSequenceSource&#125; if you required more control over the created sources. For example, if</span></span><br><span class="line"><span class="comment">     * you want to set a &#123;<span class="doctag">@link</span> WatermarkStrategy&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from The number to start at (inclusive)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to The number to stop at (inclusive)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;Long&gt; <span class="title function_">fromSequence</span><span class="params">(<span class="type">long</span> from, <span class="type">long</span> to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from &gt; to) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;Start of sequence must not be greater than the end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fromSource(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NumberSequenceSource</span>(from, to),</span><br><span class="line">                WatermarkStrategy.noWatermarks(),</span><br><span class="line">                <span class="string">&quot;Sequence Source&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains the given elements. The elements must all be of the</span></span><br><span class="line"><span class="comment">     * same type, for example, all of the &#123;<span class="doctag">@link</span> String&#125; or &#123;<span class="doctag">@link</span> Integer&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The framework will try and determine the exact type from the elements. In case of generic</span></span><br><span class="line"><span class="comment">     * elements, it may be necessary to manually supply the type information via &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #fromCollection(java.util.Collection, org.apache.flink.api.common.typeinfo.TypeInformation)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this operation will result in a non-parallel data stream source, i.e. a data</span></span><br><span class="line"><span class="comment">     * stream source with a degree of parallelism one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data The array of elements to create the data stream from.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream representing the given array of elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromElements</span><span class="params">(OUT... data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;fromElements needs at least one element as argument&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;OUT&gt; typeInfo;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            typeInfo = TypeExtractor.getForObject(data[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Could not create TypeInformation for type &quot;</span></span><br><span class="line">                            + data[<span class="number">0</span>].getClass().getName()</span><br><span class="line">                            + <span class="string">&quot;; please specify the TypeInformation manually via &quot;</span></span><br><span class="line">                            + <span class="string">&quot;StreamExecutionEnvironment#fromElements(Collection, TypeInformation)&quot;</span>,</span><br><span class="line">                    e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fromCollection(Arrays.asList(data), typeInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data set that contains the given elements. The framework will determine the</span></span><br><span class="line"><span class="comment">     * type according to the based type user supplied. The elements should be the same or be the</span></span><br><span class="line"><span class="comment">     * subclass to the based type. The sequence of elements must not be empty. Note that this</span></span><br><span class="line"><span class="comment">     * operation will result in a non-parallel data stream source, i.e. a data stream source with a</span></span><br><span class="line"><span class="comment">     * degree of parallelism one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The based class type in the collection.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data The array of elements to create the data stream from.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream representing the given array of elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromElements</span><span class="params">(Class&lt;OUT&gt; type, OUT... data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;fromElements needs at least one element as argument&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;OUT&gt; typeInfo;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            typeInfo = TypeExtractor.getForClass(type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Could not create TypeInformation for type &quot;</span></span><br><span class="line">                            + type.getName()</span><br><span class="line">                            + <span class="string">&quot;; please specify the TypeInformation manually via &quot;</span></span><br><span class="line">                            + <span class="string">&quot;StreamExecutionEnvironment#fromElements(Collection, TypeInformation)&quot;</span>,</span><br><span class="line">                    e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fromCollection(Arrays.asList(data), typeInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a data stream from the given non-empty collection. The type of the data stream is</span></span><br><span class="line"><span class="comment">     * that of the elements in the collection.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The framework will try and determine the exact type from the collection elements. In case</span></span><br><span class="line"><span class="comment">     * of generic elements, it may be necessary to manually supply the type information via &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #fromCollection(java.util.Collection, org.apache.flink.api.common.typeinfo.TypeInformation)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this operation will result in a non-parallel data stream source, i.e. a data</span></span><br><span class="line"><span class="comment">     * stream source with parallelism one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data The collection of elements to create the data stream from.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The generic type of the returned data stream.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream representing the given collection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromCollection</span><span class="params">(Collection&lt;OUT&gt; data)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(data, <span class="string">&quot;Collection must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (data.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Collection must not be empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">OUT</span> <span class="variable">first</span> <span class="operator">=</span> data.iterator().next();</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Collection must not contain null elements&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;OUT&gt; typeInfo;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            typeInfo = TypeExtractor.getForObject(first);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Could not create TypeInformation for type &quot;</span></span><br><span class="line">                            + first.getClass()</span><br><span class="line">                            + <span class="string">&quot;; please specify the TypeInformation manually via &quot;</span></span><br><span class="line">                            + <span class="string">&quot;StreamExecutionEnvironment#fromElements(Collection, TypeInformation)&quot;</span>,</span><br><span class="line">                    e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fromCollection(data, typeInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a data stream from the given non-empty collection.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this operation will result in a non-parallel data stream source, i.e., a data</span></span><br><span class="line"><span class="comment">     * stream source with parallelism one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data The collection of elements to create the data stream from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo The TypeInformation for the produced data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream representing the given collection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromCollection</span><span class="params">(</span></span><br><span class="line"><span class="params">            Collection&lt;OUT&gt; data, TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(data, <span class="string">&quot;Collection must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// must not have null elements and mixed elements</span></span><br><span class="line">        FromElementsFunction.checkCollection(data, typeInfo.getTypeClass());</span><br><span class="line"></span><br><span class="line">        SourceFunction&lt;OUT&gt; function = <span class="keyword">new</span> <span class="title class_">FromElementsFunction</span>&lt;&gt;(data);</span><br><span class="line">        <span class="keyword">return</span> addSource(function, <span class="string">&quot;Collection Source&quot;</span>, typeInfo, Boundedness.BOUNDED)</span><br><span class="line">                .setParallelism(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a data stream from the given iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Because the iterator will remain unmodified until the actual execution happens, the type</span></span><br><span class="line"><span class="comment">     * of data returned by the iterator must be given explicitly in the form of the type class (this</span></span><br><span class="line"><span class="comment">     * is due to the fact that the Java compiler erases the generic type information).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this operation will result in a non-parallel data stream source, i.e., a data</span></span><br><span class="line"><span class="comment">     * stream source with a parallelism of one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data The iterator of elements to create the data stream from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the data produced by the iterator. Must not be a generic class.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream representing the elements in the iterator</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #fromCollection(java.util.Iterator,</span></span><br><span class="line"><span class="comment">     *     org.apache.flink.api.common.typeinfo.TypeInformation)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromCollection</span><span class="params">(Iterator&lt;OUT&gt; data, Class&lt;OUT&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fromCollection(data, TypeExtractor.getForClass(type));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a data stream from the given iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Because the iterator will remain unmodified until the actual execution happens, the type</span></span><br><span class="line"><span class="comment">     * of data returned by the iterator must be given explicitly in the form of the type</span></span><br><span class="line"><span class="comment">     * information. This method is useful for cases where the type is generic. In that case, the</span></span><br><span class="line"><span class="comment">     * type class (as given in &#123;<span class="doctag">@link</span> #fromCollection(java.util.Iterator, Class)&#125; does not supply</span></span><br><span class="line"><span class="comment">     * all type information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this operation will result in a non-parallel data stream source, i.e., a data</span></span><br><span class="line"><span class="comment">     * stream source with parallelism one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data The iterator of elements to create the data stream from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo The TypeInformation for the produced data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream representing the elements in the iterator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromCollection</span><span class="params">(</span></span><br><span class="line"><span class="params">            Iterator&lt;OUT&gt; data, TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(data, <span class="string">&quot;The iterator must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SourceFunction&lt;OUT&gt; function = <span class="keyword">new</span> <span class="title class_">FromIteratorFunction</span>&lt;&gt;(data);</span><br><span class="line">        <span class="keyword">return</span> addSource(function, <span class="string">&quot;Collection Source&quot;</span>, typeInfo, Boundedness.BOUNDED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains elements in the iterator. The iterator is splittable,</span></span><br><span class="line"><span class="comment">     * allowing the framework to create a parallel data stream source that returns the elements in</span></span><br><span class="line"><span class="comment">     * the iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Because the iterator will remain unmodified until the actual execution happens, the type</span></span><br><span class="line"><span class="comment">     * of data returned by the iterator must be given explicitly in the form of the type class (this</span></span><br><span class="line"><span class="comment">     * is due to the fact that the Java compiler erases the generic type information).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iterator The iterator that produces the elements of the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the data produced by the iterator. Must not be a generic class.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream representing the elements in the iterator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromParallelCollection</span><span class="params">(</span></span><br><span class="line"><span class="params">            SplittableIterator&lt;OUT&gt; iterator, Class&lt;OUT&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fromParallelCollection(iterator, TypeExtractor.getForClass(type));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains elements in the iterator. The iterator is splittable,</span></span><br><span class="line"><span class="comment">     * allowing the framework to create a parallel data stream source that returns the elements in</span></span><br><span class="line"><span class="comment">     * the iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Because the iterator will remain unmodified until the actual execution happens, the type</span></span><br><span class="line"><span class="comment">     * of data returned by the iterator must be given explicitly in the form of the type</span></span><br><span class="line"><span class="comment">     * information. This method is useful for cases where the type is generic. In that case, the</span></span><br><span class="line"><span class="comment">     * type class (as given in &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #fromParallelCollection(org.apache.flink.util.SplittableIterator, Class)&#125; does not supply all</span></span><br><span class="line"><span class="comment">     * type information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iterator The iterator that produces the elements of the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo The TypeInformation for the produced data stream.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream representing the elements in the iterator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromParallelCollection</span><span class="params">(</span></span><br><span class="line"><span class="params">            SplittableIterator&lt;OUT&gt; iterator, TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fromParallelCollection(iterator, typeInfo, <span class="string">&quot;Parallel Collection Source&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private helper for passing different names</span></span><br><span class="line">    <span class="keyword">private</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromParallelCollection</span><span class="params">(</span></span><br><span class="line"><span class="params">            SplittableIterator&lt;OUT&gt; iterator, TypeInformation&lt;OUT&gt; typeInfo, String operatorName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addSource(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FromSplittableIteratorFunction</span>&lt;&gt;(iterator),</span><br><span class="line">                operatorName,</span><br><span class="line">                typeInfo,</span><br><span class="line">                Boundedness.BOUNDED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the given file line-by-line and creates a data stream that contains a string with the</span></span><br><span class="line"><span class="comment">     * contents of each such line. The file will be read with the UTF-8 character set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; The source monitors the path, creates the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards them to</span></span><br><span class="line"><span class="comment">     * the downstream readers to read the actual data, and exits, without waiting for the readers to</span></span><br><span class="line"><span class="comment">     * finish reading. This implies that no more checkpoint barriers are going to be forwarded after</span></span><br><span class="line"><span class="comment">     * the source exits, thus having no checkpoints after that point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path&quot;).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data read from the given file as text lines</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">readTextFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> readTextFile(filePath, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the given file line-by-line and creates a data stream that contains a string with the</span></span><br><span class="line"><span class="comment">     * contents of each such line. The &#123;<span class="doctag">@link</span> java.nio.charset.Charset&#125; with the given name will be</span></span><br><span class="line"><span class="comment">     * used to read the files.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; The source monitors the path, creates the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards them to</span></span><br><span class="line"><span class="comment">     * the downstream readers to read the actual data, and exits, without waiting for the readers to</span></span><br><span class="line"><span class="comment">     * finish reading. This implies that no more checkpoint barriers are going to be forwarded after</span></span><br><span class="line"><span class="comment">     * the source exits, thus having no checkpoints after that point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charsetName The name of the character set used to read the file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data read from the given file as text lines</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">readTextFile</span><span class="params">(String filePath, String charsetName)</span> &#123;</span><br><span class="line">        Preconditions.checkArgument(</span><br><span class="line">                !StringUtils.isNullOrWhitespaceOnly(filePath),</span><br><span class="line">                <span class="string">&quot;The file path must not be null or blank.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TextInputFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextInputFormat</span>(<span class="keyword">new</span> <span class="title class_">Path</span>(filePath));</span><br><span class="line">        format.setFilesFilter(FilePathFilter.createDefaultFilter());</span><br><span class="line">        TypeInformation&lt;String&gt; typeInfo = BasicTypeInfo.STRING_TYPE_INFO;</span><br><span class="line">        format.setCharsetName(charsetName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> readFile(format, filePath, FileProcessingMode.PROCESS_ONCE, -<span class="number">1</span>, typeInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the contents of the user-specified &#123;<span class="doctag">@code</span> filePath&#125; based on the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileInputFormat&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Since all data streams need specific information about their types, this method needs to</span></span><br><span class="line"><span class="comment">     * determine the type of the data produced by the input format. It will attempt to determine the</span></span><br><span class="line"><span class="comment">     * data type by reflection, unless the input format implements the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.java.typeutils.ResultTypeQueryable&#125; interface. In the latter case, this</span></span><br><span class="line"><span class="comment">     * method will invoke the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.java.typeutils.ResultTypeQueryable#getProducedType()&#125; method to</span></span><br><span class="line"><span class="comment">     * determine data type produced by the input format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; The source monitors the path, creates the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards them to</span></span><br><span class="line"><span class="comment">     * the downstream readers to read the actual data, and exits, without waiting for the readers to</span></span><br><span class="line"><span class="comment">     * finish reading. This implies that no more checkpoint barriers are going to be forwarded after</span></span><br><span class="line"><span class="comment">     * the source exits, thus having no checkpoints after that point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFormat The input format used to create the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data read from the given file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">readFile</span><span class="params">(FileInputFormat&lt;OUT&gt; inputFormat, String filePath)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> readFile(inputFormat, filePath, FileProcessingMode.PROCESS_ONCE, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the contents of the user-specified &#123;<span class="doctag">@code</span> filePath&#125; based on the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileInputFormat&#125;. Depending on the provided &#123;<span class="doctag">@link</span> FileProcessingMode&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;See &#123;<span class="doctag">@link</span> #readFile(FileInputFormat, String, FileProcessingMode, long)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFormat The input format used to create the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watchType The mode in which the source should operate, i.e. monitor path and react to</span></span><br><span class="line"><span class="comment">     *     new data, or process once and exit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval In the case of periodic path monitoring, this specifies the interval (in</span></span><br><span class="line"><span class="comment">     *     millis) between consecutive path scans</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filter The files to be excluded from the processing</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data read from the given file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> FileInputFormat#setFilesFilter(FilePathFilter)&#125; to set a filter and</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@link</span> StreamExecutionEnvironment#readFile(FileInputFormat, String, FileProcessingMode,</span></span><br><span class="line"><span class="comment">     *     long)&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">readFile</span><span class="params">(</span></span><br><span class="line"><span class="params">            FileInputFormat&lt;OUT&gt; inputFormat,</span></span><br><span class="line"><span class="params">            String filePath,</span></span><br><span class="line"><span class="params">            FileProcessingMode watchType,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> interval,</span></span><br><span class="line"><span class="params">            FilePathFilter filter)</span> &#123;</span><br><span class="line">        inputFormat.setFilesFilter(filter);</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;OUT&gt; typeInformation;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            typeInformation = TypeExtractor.getInputFormatTypes(inputFormat);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidProgramException</span>(</span><br><span class="line">                    <span class="string">&quot;The type returned by the input format could not be &quot;</span></span><br><span class="line">                            + <span class="string">&quot;automatically determined. Please specify the TypeInformation of the produced type &quot;</span></span><br><span class="line">                            + <span class="string">&quot;explicitly by using the &#x27;createInput(InputFormat, TypeInformation)&#x27; method instead.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readFile(inputFormat, filePath, watchType, interval, typeInformation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the contents of the user-specified &#123;<span class="doctag">@code</span> filePath&#125; based on the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileInputFormat&#125;. Depending on the provided &#123;<span class="doctag">@link</span> FileProcessingMode&#125;, the source may</span></span><br><span class="line"><span class="comment">     * periodically monitor (every &#123;<span class="doctag">@code</span> interval&#125; ms) the path for new data (&#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileProcessingMode#PROCESS_CONTINUOUSLY&#125;), or process once the data currently in the path and</span></span><br><span class="line"><span class="comment">     * exit (&#123;<span class="doctag">@link</span> FileProcessingMode#PROCESS_ONCE&#125;). In addition, if the path contains files not</span></span><br><span class="line"><span class="comment">     * to be processed, the user can specify a custom &#123;<span class="doctag">@link</span> FilePathFilter&#125;. As a default</span></span><br><span class="line"><span class="comment">     * implementation you can use &#123;<span class="doctag">@link</span> FilePathFilter#createDefaultFilter()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Since all data streams need specific information about their types, this method needs to</span></span><br><span class="line"><span class="comment">     * determine the type of the data produced by the input format. It will attempt to determine the</span></span><br><span class="line"><span class="comment">     * data type by reflection, unless the input format implements the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.java.typeutils.ResultTypeQueryable&#125; interface. In the latter case, this</span></span><br><span class="line"><span class="comment">     * method will invoke the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.java.typeutils.ResultTypeQueryable#getProducedType()&#125; method to</span></span><br><span class="line"><span class="comment">     * determine data type produced by the input format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; If the &#123;<span class="doctag">@code</span> watchType&#125; is set to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileProcessingMode#PROCESS_ONCE&#125;, the source monitors the path &lt;b&gt;once&lt;/b&gt;, creates the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards</span></span><br><span class="line"><span class="comment">     * them to the downstream readers to read the actual data, and exits, without waiting for the</span></span><br><span class="line"><span class="comment">     * readers to finish reading. This implies that no more checkpoint barriers are going to be</span></span><br><span class="line"><span class="comment">     * forwarded after the source exits, thus having no checkpoints after that point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFormat The input format used to create the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watchType The mode in which the source should operate, i.e. monitor path and react to</span></span><br><span class="line"><span class="comment">     *     new data, or process once and exit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval In the case of periodic path monitoring, this specifies the interval (in</span></span><br><span class="line"><span class="comment">     *     millis) between consecutive path scans</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data read from the given file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">readFile</span><span class="params">(</span></span><br><span class="line"><span class="params">            FileInputFormat&lt;OUT&gt; inputFormat,</span></span><br><span class="line"><span class="params">            String filePath,</span></span><br><span class="line"><span class="params">            FileProcessingMode watchType,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> interval)</span> &#123;</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;OUT&gt; typeInformation;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            typeInformation = TypeExtractor.getInputFormatTypes(inputFormat);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidProgramException</span>(</span><br><span class="line">                    <span class="string">&quot;The type returned by the input format could not be &quot;</span></span><br><span class="line">                            + <span class="string">&quot;automatically determined. Please specify the TypeInformation of the produced type &quot;</span></span><br><span class="line">                            + <span class="string">&quot;explicitly by using the &#x27;createInput(InputFormat, TypeInformation)&#x27; method instead.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readFile(inputFormat, filePath, watchType, interval, typeInformation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a data stream that contains the contents of file created while system watches the</span></span><br><span class="line"><span class="comment">     * given path. The file will be read with the system&#x27;s default character set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path/&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intervalMillis The interval of file watching in milliseconds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watchType The watch type of file stream. When watchType is &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     org.apache.flink.streaming.api.functions.source.FileMonitoringFunction.WatchType#ONLY_NEW_FILES&#125;,</span></span><br><span class="line"><span class="comment">     *     the system processes only new files. &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     org.apache.flink.streaming.api.functions.source.FileMonitoringFunction.WatchType#REPROCESS_WITH_APPENDED&#125;</span></span><br><span class="line"><span class="comment">     *     means that the system re-processes all contents of appended file. &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     org.apache.flink.streaming.api.functions.source.FileMonitoringFunction.WatchType#PROCESS_ONLY_APPENDED&#125;</span></span><br><span class="line"><span class="comment">     *     means that the system processes only appended contents of files.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The DataStream containing the given directory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #readFile(FileInputFormat, String, FileProcessingMode, long)&#125; instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataStream&lt;String&gt; <span class="title function_">readFileStream</span><span class="params">(</span></span><br><span class="line"><span class="params">            String filePath, <span class="type">long</span> intervalMillis, FileMonitoringFunction.WatchType watchType)</span> &#123;</span><br><span class="line">        DataStream&lt;Tuple3&lt;String, Long, Long&gt;&gt; source =</span><br><span class="line">                addSource(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">FileMonitoringFunction</span>(filePath, intervalMillis, watchType),</span><br><span class="line">                        <span class="string">&quot;Read File Stream source&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> source.flatMap(<span class="keyword">new</span> <span class="title class_">FileReadFunction</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the contents of the user-specified &#123;<span class="doctag">@code</span> filePath&#125; based on the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileInputFormat&#125;. Depending on the provided &#123;<span class="doctag">@link</span> FileProcessingMode&#125;, the source may</span></span><br><span class="line"><span class="comment">     * periodically monitor (every &#123;<span class="doctag">@code</span> interval&#125; ms) the path for new data (&#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileProcessingMode#PROCESS_CONTINUOUSLY&#125;), or process once the data currently in the path and</span></span><br><span class="line"><span class="comment">     * exit (&#123;<span class="doctag">@link</span> FileProcessingMode#PROCESS_ONCE&#125;). In addition, if the path contains files not</span></span><br><span class="line"><span class="comment">     * to be processed, the user can specify a custom &#123;<span class="doctag">@link</span> FilePathFilter&#125;. As a default</span></span><br><span class="line"><span class="comment">     * implementation you can use &#123;<span class="doctag">@link</span> FilePathFilter#createDefaultFilter()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; If the &#123;<span class="doctag">@code</span> watchType&#125; is set to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileProcessingMode#PROCESS_ONCE&#125;, the source monitors the path &lt;b&gt;once&lt;/b&gt;, creates the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards</span></span><br><span class="line"><span class="comment">     * them to the downstream readers to read the actual data, and exits, without waiting for the</span></span><br><span class="line"><span class="comment">     * readers to finish reading. This implies that no more checkpoint barriers are going to be</span></span><br><span class="line"><span class="comment">     * forwarded after the source exits, thus having no checkpoints after that point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFormat The input format used to create the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watchType The mode in which the source should operate, i.e. monitor path and react to</span></span><br><span class="line"><span class="comment">     *     new data, or process once and exit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInformation Information on the type of the elements in the output stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval In the case of periodic path monitoring, this specifies the interval (in</span></span><br><span class="line"><span class="comment">     *     millis) between consecutive path scans</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data read from the given file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">readFile</span><span class="params">(</span></span><br><span class="line"><span class="params">            FileInputFormat&lt;OUT&gt; inputFormat,</span></span><br><span class="line"><span class="params">            String filePath,</span></span><br><span class="line"><span class="params">            FileProcessingMode watchType,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> interval,</span></span><br><span class="line"><span class="params">            TypeInformation&lt;OUT&gt; typeInformation)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Preconditions.checkNotNull(inputFormat, <span class="string">&quot;InputFormat must not be null.&quot;</span>);</span><br><span class="line">        Preconditions.checkArgument(</span><br><span class="line">                !StringUtils.isNullOrWhitespaceOnly(filePath),</span><br><span class="line">                <span class="string">&quot;The file path must not be null or blank.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        inputFormat.setFilePath(filePath);</span><br><span class="line">        <span class="keyword">return</span> createFileInput(</span><br><span class="line">                inputFormat, typeInformation, <span class="string">&quot;Custom File Source&quot;</span>, watchType, interval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains the strings received infinitely from a socket.</span></span><br><span class="line"><span class="comment">     * Received strings are decoded by the system&#x27;s default character set. On the termination of the</span></span><br><span class="line"><span class="comment">     * socket server connection retries can be initiated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Let us note that the socket itself does not report on abort and as a consequence retries</span></span><br><span class="line"><span class="comment">     * are only initiated when the socket was gracefully terminated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hostname The host name which a server socket binds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port number which a server socket binds. A port number of 0 means that the</span></span><br><span class="line"><span class="comment">     *     port number is automatically allocated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delimiter A character which splits received strings into records</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxRetry The maximal retry interval in seconds while the program waits for a socket</span></span><br><span class="line"><span class="comment">     *     that is temporarily down. Reconnection is initiated every second. A number of 0 means</span></span><br><span class="line"><span class="comment">     *     that the reader is immediately terminated, while a negative value ensures retrying</span></span><br><span class="line"><span class="comment">     *     forever.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream containing the strings received from the socket</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #socketTextStream(String, int, String, long)&#125; instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">socketTextStream</span><span class="params">(</span></span><br><span class="line"><span class="params">            String hostname, <span class="type">int</span> port, <span class="type">char</span> delimiter, <span class="type">long</span> maxRetry)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> socketTextStream(hostname, port, String.valueOf(delimiter), maxRetry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains the strings received infinitely from a socket.</span></span><br><span class="line"><span class="comment">     * Received strings are decoded by the system&#x27;s default character set. On the termination of the</span></span><br><span class="line"><span class="comment">     * socket server connection retries can be initiated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Let us note that the socket itself does not report on abort and as a consequence retries</span></span><br><span class="line"><span class="comment">     * are only initiated when the socket was gracefully terminated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hostname The host name which a server socket binds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port number which a server socket binds. A port number of 0 means that the</span></span><br><span class="line"><span class="comment">     *     port number is automatically allocated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delimiter A string which splits received strings into records</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxRetry The maximal retry interval in seconds while the program waits for a socket</span></span><br><span class="line"><span class="comment">     *     that is temporarily down. Reconnection is initiated every second. A number of 0 means</span></span><br><span class="line"><span class="comment">     *     that the reader is immediately terminated, while a negative value ensures retrying</span></span><br><span class="line"><span class="comment">     *     forever.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream containing the strings received from the socket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">socketTextStream</span><span class="params">(</span></span><br><span class="line"><span class="params">            String hostname, <span class="type">int</span> port, String delimiter, <span class="type">long</span> maxRetry)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addSource(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SocketTextStreamFunction</span>(hostname, port, delimiter, maxRetry), <span class="string">&quot;Socket Stream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains the strings received infinitely from a socket.</span></span><br><span class="line"><span class="comment">     * Received strings are decoded by the system&#x27;s default character set. The reader is terminated</span></span><br><span class="line"><span class="comment">     * immediately when the socket is down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hostname The host name which a server socket binds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port number which a server socket binds. A port number of 0 means that the</span></span><br><span class="line"><span class="comment">     *     port number is automatically allocated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delimiter A character which splits received strings into records</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream containing the strings received from the socket</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #socketTextStream(String, int, String)&#125; instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">socketTextStream</span><span class="params">(String hostname, <span class="type">int</span> port, <span class="type">char</span> delimiter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> socketTextStream(hostname, port, delimiter, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains the strings received infinitely from a socket.</span></span><br><span class="line"><span class="comment">     * Received strings are decoded by the system&#x27;s default character set. The reader is terminated</span></span><br><span class="line"><span class="comment">     * immediately when the socket is down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hostname The host name which a server socket binds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port number which a server socket binds. A port number of 0 means that the</span></span><br><span class="line"><span class="comment">     *     port number is automatically allocated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delimiter A string which splits received strings into records</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream containing the strings received from the socket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">socketTextStream</span><span class="params">(String hostname, <span class="type">int</span> port, String delimiter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> socketTextStream(hostname, port, delimiter, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains the strings received infinitely from a socket.</span></span><br><span class="line"><span class="comment">     * Received strings are decoded by the system&#x27;s default character set, using&quot;\n&quot; as delimiter.</span></span><br><span class="line"><span class="comment">     * The reader is terminated immediately when the socket is down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hostname The host name which a server socket binds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port number which a server socket binds. A port number of 0 means that the</span></span><br><span class="line"><span class="comment">     *     port number is automatically allocated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream containing the strings received from the socket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">socketTextStream</span><span class="params">(String hostname, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> socketTextStream(hostname, port, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generic method to create an input data stream with &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.common.io.InputFormat&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Since all data streams need specific information about their types, this method needs to</span></span><br><span class="line"><span class="comment">     * determine the type of the data produced by the input format. It will attempt to determine the</span></span><br><span class="line"><span class="comment">     * data type by reflection, unless the input format implements the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.java.typeutils.ResultTypeQueryable&#125; interface. In the latter case, this</span></span><br><span class="line"><span class="comment">     * method will invoke the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.java.typeutils.ResultTypeQueryable#getProducedType()&#125; method to</span></span><br><span class="line"><span class="comment">     * determine data type produced by the input format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; In the case of a &#123;<span class="doctag">@link</span> FileInputFormat&#125;, the source</span></span><br><span class="line"><span class="comment">     * (which executes the &#123;<span class="doctag">@link</span> ContinuousFileMonitoringFunction&#125;) monitors the path, creates the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards</span></span><br><span class="line"><span class="comment">     * them to the downstream readers to read the actual data, and exits, without waiting for the</span></span><br><span class="line"><span class="comment">     * readers to finish reading. This implies that no more checkpoint barriers are going to be</span></span><br><span class="line"><span class="comment">     * forwarded after the source exits, thus having no checkpoints.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFormat The input format used to create the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data created by the input format</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">createInput</span><span class="params">(InputFormat&lt;OUT, ?&gt; inputFormat)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createInput(inputFormat, TypeExtractor.getInputFormatTypes(inputFormat));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generic method to create an input data stream with &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.common.io.InputFormat&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The data stream is typed to the given TypeInformation. This method is intended for input</span></span><br><span class="line"><span class="comment">     * formats where the return type cannot be determined by reflection analysis, and that do not</span></span><br><span class="line"><span class="comment">     * implement the &#123;<span class="doctag">@link</span> org.apache.flink.api.java.typeutils.ResultTypeQueryable&#125; interface.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; In the case of a &#123;<span class="doctag">@link</span> FileInputFormat&#125;, the source</span></span><br><span class="line"><span class="comment">     * (which executes the &#123;<span class="doctag">@link</span> ContinuousFileMonitoringFunction&#125;) monitors the path, creates the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards</span></span><br><span class="line"><span class="comment">     * them to the downstream readers to read the actual data, and exits, without waiting for the</span></span><br><span class="line"><span class="comment">     * readers to finish reading. This implies that no more checkpoint barriers are going to be</span></span><br><span class="line"><span class="comment">     * forwarded after the source exits, thus having no checkpoints.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFormat The input format used to create the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo The information about the type of the output type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data created by the input format</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">createInput</span><span class="params">(</span></span><br><span class="line"><span class="params">            InputFormat&lt;OUT, ?&gt; inputFormat, TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        DataStreamSource&lt;OUT&gt; source;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inputFormat <span class="keyword">instanceof</span> FileInputFormat) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            FileInputFormat&lt;OUT&gt; format = (FileInputFormat&lt;OUT&gt;) inputFormat;</span><br><span class="line"></span><br><span class="line">            source =</span><br><span class="line">                    createFileInput(</span><br><span class="line">                            format,</span><br><span class="line">                            typeInfo,</span><br><span class="line">                            <span class="string">&quot;Custom File source&quot;</span>,</span><br><span class="line">                            FileProcessingMode.PROCESS_ONCE,</span><br><span class="line">                            -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            source = createInput(inputFormat, typeInfo, <span class="string">&quot;Custom Source&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">createInput</span><span class="params">(</span></span><br><span class="line"><span class="params">            InputFormat&lt;OUT, ?&gt; inputFormat, TypeInformation&lt;OUT&gt; typeInfo, String sourceName)</span> &#123;</span><br><span class="line"></span><br><span class="line">        InputFormatSourceFunction&lt;OUT&gt; function =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InputFormatSourceFunction</span>&lt;&gt;(inputFormat, typeInfo);</span><br><span class="line">        <span class="keyword">return</span> addSource(function, sourceName, typeInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">createFileInput</span><span class="params">(</span></span><br><span class="line"><span class="params">            FileInputFormat&lt;OUT&gt; inputFormat,</span></span><br><span class="line"><span class="params">            TypeInformation&lt;OUT&gt; typeInfo,</span></span><br><span class="line"><span class="params">            String sourceName,</span></span><br><span class="line"><span class="params">            FileProcessingMode monitoringMode,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> interval)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Preconditions.checkNotNull(inputFormat, <span class="string">&quot;Unspecified file input format.&quot;</span>);</span><br><span class="line">        Preconditions.checkNotNull(typeInfo, <span class="string">&quot;Unspecified output type information.&quot;</span>);</span><br><span class="line">        Preconditions.checkNotNull(sourceName, <span class="string">&quot;Unspecified name for the source.&quot;</span>);</span><br><span class="line">        Preconditions.checkNotNull(monitoringMode, <span class="string">&quot;Unspecified monitoring mode.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Preconditions.checkArgument(</span><br><span class="line">                monitoringMode.equals(FileProcessingMode.PROCESS_ONCE)</span><br><span class="line">                        || interval &gt;= ContinuousFileMonitoringFunction.MIN_MONITORING_INTERVAL,</span><br><span class="line">                <span class="string">&quot;The path monitoring interval cannot be less than &quot;</span></span><br><span class="line">                        + ContinuousFileMonitoringFunction.MIN_MONITORING_INTERVAL</span><br><span class="line">                        + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ContinuousFileMonitoringFunction&lt;OUT&gt; monitoringFunction =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ContinuousFileMonitoringFunction</span>&lt;&gt;(</span><br><span class="line">                        inputFormat, monitoringMode, getParallelism(), interval);</span><br><span class="line"></span><br><span class="line">        ContinuousFileReaderOperatorFactory&lt;OUT, TimestampedFileInputSplit&gt; factory =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ContinuousFileReaderOperatorFactory</span>&lt;&gt;(inputFormat);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boundedness</span> <span class="variable">boundedness</span> <span class="operator">=</span></span><br><span class="line">                monitoringMode == FileProcessingMode.PROCESS_ONCE</span><br><span class="line">                        ? Boundedness.BOUNDED</span><br><span class="line">                        : Boundedness.CONTINUOUS_UNBOUNDED;</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;OUT&gt; source =</span><br><span class="line">                addSource(monitoringFunction, sourceName, <span class="literal">null</span>, boundedness)</span><br><span class="line">                        .transform(<span class="string">&quot;Split Reader: &quot;</span> + sourceName, typeInfo, factory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataStreamSource</span>&lt;&gt;(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a Data Source to the streaming topology.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;By default sources have a parallelism of 1. To enable parallel execution, the user defined</span></span><br><span class="line"><span class="comment">     * source should implement &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.streaming.api.functions.source.ParallelSourceFunction&#125; or extend &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.streaming.api.functions.source.RichParallelSourceFunction&#125;. In these cases</span></span><br><span class="line"><span class="comment">     * the resulting source will have the parallelism of the environment. To change this afterwards</span></span><br><span class="line"><span class="comment">     * call &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.datastream.DataStreamSource#setParallelism(int)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function the user defined function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; type of the returned stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data stream constructed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">addSource</span><span class="params">(SourceFunction&lt;OUT&gt; function)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addSource(function, <span class="string">&quot;Custom Source&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a data source with a custom type information thus opening a &#123;<span class="doctag">@link</span> DataStream&#125;. Only in</span></span><br><span class="line"><span class="comment">     * very special cases does the user need to support type information. Otherwise use &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #addSource(org.apache.flink.streaming.api.functions.source.SourceFunction)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function the user defined function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceName Name of the data source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; type of the returned stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data stream constructed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">addSource</span><span class="params">(SourceFunction&lt;OUT&gt; function, String sourceName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addSource(function, sourceName, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ads a data source with a custom type information thus opening a &#123;<span class="doctag">@link</span> DataStream&#125;. Only in</span></span><br><span class="line"><span class="comment">     * very special cases does the user need to support type information. Otherwise use &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #addSource(org.apache.flink.streaming.api.functions.source.SourceFunction)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function the user defined function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; type of the returned stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo the user defined type information for the stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data stream constructed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">addSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            SourceFunction&lt;OUT&gt; function, TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addSource(function, <span class="string">&quot;Custom Source&quot;</span>, typeInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ads a data source with a custom type information thus opening a &#123;<span class="doctag">@link</span> DataStream&#125;. Only in</span></span><br><span class="line"><span class="comment">     * very special cases does the user need to support type information. Otherwise use &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #addSource(org.apache.flink.streaming.api.functions.source.SourceFunction)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function the user defined function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceName Name of the data source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; type of the returned stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo the user defined type information for the stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data stream constructed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">addSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            SourceFunction&lt;OUT&gt; function, String sourceName, TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addSource(function, sourceName, typeInfo, Boundedness.CONTINUOUS_UNBOUNDED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">addSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> SourceFunction&lt;OUT&gt; function,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> String sourceName,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> <span class="keyword">final</span> TypeInformation&lt;OUT&gt; typeInfo,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> Boundedness boundedness)</span> &#123;</span><br><span class="line">        checkNotNull(function);</span><br><span class="line">        checkNotNull(sourceName);</span><br><span class="line">        checkNotNull(boundedness);</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;OUT&gt; resolvedTypeInfo =</span><br><span class="line">                getTypeInfo(function, sourceName, SourceFunction.class, typeInfo);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isParallel</span> <span class="operator">=</span> function <span class="keyword">instanceof</span> ParallelSourceFunction;</span><br><span class="line"></span><br><span class="line">        clean(function);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> StreamSource&lt;OUT, ?&gt; sourceOperator = <span class="keyword">new</span> <span class="title class_">StreamSource</span>&lt;&gt;(function);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataStreamSource</span>&lt;&gt;(</span><br><span class="line">                <span class="built_in">this</span>, resolvedTypeInfo, sourceOperator, isParallel, sourceName, boundedness);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a data &#123;<span class="doctag">@link</span> Source&#125; to the environment to get a &#123;<span class="doctag">@link</span> DataStream&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The result will be either a bounded data stream (that can be processed in a batch way) or</span></span><br><span class="line"><span class="comment">     * an unbounded data stream (that must be processed in a streaming way), based on the</span></span><br><span class="line"><span class="comment">     * boundedness property of the source, as defined by &#123;<span class="doctag">@link</span> Source#getBoundedness()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The result type (that is used to create serializers for the produced data events) will be</span></span><br><span class="line"><span class="comment">     * automatically extracted. This is useful for sources that describe the produced types already</span></span><br><span class="line"><span class="comment">     * in their configuration, to avoid having to declare the type multiple times. For example the</span></span><br><span class="line"><span class="comment">     * file sources and Kafka sources already define the produced byte their</span></span><br><span class="line"><span class="comment">     * parsers/serializers/formats, and can forward that information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source the user defined source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceName Name of the data source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; type of the returned stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data stream constructed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Experimental</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            Source&lt;OUT, ?, ?&gt; source,</span></span><br><span class="line"><span class="params">            WatermarkStrategy&lt;OUT&gt; timestampsAndWatermarks,</span></span><br><span class="line"><span class="params">            String sourceName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fromSource(source, timestampsAndWatermarks, sourceName, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a data &#123;<span class="doctag">@link</span> Source&#125; to the environment to get a &#123;<span class="doctag">@link</span> DataStream&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The result will be either a bounded data stream (that can be processed in a batch way) or</span></span><br><span class="line"><span class="comment">     * an unbounded data stream (that must be processed in a streaming way), based on the</span></span><br><span class="line"><span class="comment">     * boundedness property of the source, as defined by &#123;<span class="doctag">@link</span> Source#getBoundedness()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method takes an explicit type information for the produced data stream, so that</span></span><br><span class="line"><span class="comment">     * callers can define directly what type/serializer will be used for the produced stream. For</span></span><br><span class="line"><span class="comment">     * sources that describe their produced type, the method &#123;<span class="doctag">@link</span> #fromSource(Source,</span></span><br><span class="line"><span class="comment">     * WatermarkStrategy, String)&#125; can be used to avoid specifying the produced type redundantly.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source the user defined source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceName Name of the data source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; type of the returned stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo the user defined type information for the stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data stream constructed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Experimental</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            Source&lt;OUT, ?, ?&gt; source,</span></span><br><span class="line"><span class="params">            WatermarkStrategy&lt;OUT&gt; timestampsAndWatermarks,</span></span><br><span class="line"><span class="params">            String sourceName,</span></span><br><span class="line"><span class="params">            TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TypeInformation&lt;OUT&gt; resolvedTypeInfo =</span><br><span class="line">                getTypeInfo(source, sourceName, Source.class, typeInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataStreamSource</span>&lt;&gt;(</span><br><span class="line">                <span class="built_in">this</span>,</span><br><span class="line">                checkNotNull(source, <span class="string">&quot;source&quot;</span>),</span><br><span class="line">                checkNotNull(timestampsAndWatermarks, <span class="string">&quot;timestampsAndWatermarks&quot;</span>),</span><br><span class="line">                checkNotNull(resolvedTypeInfo),</span><br><span class="line">                checkNotNull(sourceName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Triggers the program execution. The environment will execute all parts of the program that</span></span><br><span class="line"><span class="comment">     * have resulted in a &quot;sink&quot; operation. Sink operations are for example printing results or</span></span><br><span class="line"><span class="comment">     * forwarding them to a message queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The program execution will be logged and displayed with a generated default name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The result of the job execution, containing elapsed time and accumulators.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception which occurs during job execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> JobExecutionResult <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> execute(getJobName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Triggers the program execution. The environment will execute all parts of the program that</span></span><br><span class="line"><span class="comment">     * have resulted in a &quot;sink&quot; operation. Sink operations are for example printing results or</span></span><br><span class="line"><span class="comment">     * forwarding them to a message queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The program execution will be logged and displayed with the provided name</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName Desired name of the job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The result of the job execution, containing elapsed time and accumulators.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception which occurs during job execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> JobExecutionResult <span class="title function_">execute</span><span class="params">(String jobName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Preconditions.checkNotNull(jobName, <span class="string">&quot;Streaming Job name should not be null.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> execute(getStreamGraph(jobName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Triggers the program execution. The environment will execute all parts of the program that</span></span><br><span class="line"><span class="comment">     * have resulted in a &quot;sink&quot; operation. Sink operations are for example printing results or</span></span><br><span class="line"><span class="comment">     * forwarding them to a message queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> streamGraph the stream graph representing the transformations</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The result of the job execution, containing elapsed time and accumulators.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception which occurs during job execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> JobExecutionResult <span class="title function_">execute</span><span class="params">(StreamGraph streamGraph)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">JobClient</span> <span class="variable">jobClient</span> <span class="operator">=</span> executeAsync(streamGraph);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> JobExecutionResult jobExecutionResult;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (configuration.getBoolean(DeploymentOptions.ATTACHED)) &#123;</span><br><span class="line">                jobExecutionResult = jobClient.getJobExecutionResult().get();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                jobExecutionResult = <span class="keyword">new</span> <span class="title class_">DetachedJobExecutionResult</span>(jobClient.getJobID());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            jobListeners.forEach(</span><br><span class="line">                    jobListener -&gt; jobListener.onJobExecuted(jobExecutionResult, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> jobExecutionResult;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// get() on the JobExecutionResult Future will throw an ExecutionException. This</span></span><br><span class="line">            <span class="comment">// behaviour was largely not there in Flink versions before the PipelineExecutor</span></span><br><span class="line">            <span class="comment">// refactoring so we should strip that exception.</span></span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">strippedException</span> <span class="operator">=</span> ExceptionUtils.stripExecutionException(t);</span><br><span class="line"></span><br><span class="line">            jobListeners.forEach(</span><br><span class="line">                    jobListener -&gt; &#123;</span><br><span class="line">                        jobListener.onJobExecuted(<span class="literal">null</span>, strippedException);</span><br><span class="line">                    &#125;);</span><br><span class="line">            ExceptionUtils.rethrowException(strippedException);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// never reached, only make javac happy</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register a &#123;<span class="doctag">@link</span> JobListener&#125; in this environment. The &#123;<span class="doctag">@link</span> JobListener&#125; will be notified</span></span><br><span class="line"><span class="comment">     * on specific job status changed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerJobListener</span><span class="params">(JobListener jobListener)</span> &#123;</span><br><span class="line">        checkNotNull(jobListener, <span class="string">&quot;JobListener cannot be null&quot;</span>);</span><br><span class="line">        jobListeners.add(jobListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Clear all registered &#123;<span class="doctag">@link</span> JobListener&#125;s. */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearJobListeners</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jobListeners.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Triggers the program asynchronously. The environment will execute all parts of the program</span></span><br><span class="line"><span class="comment">     * that have resulted in a &quot;sink&quot; operation. Sink operations are for example printing results or</span></span><br><span class="line"><span class="comment">     * forwarding them to a message queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The program execution will be logged and displayed with a generated default name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> JobClient&#125; that can be used to communicate with the submitted job, completed</span></span><br><span class="line"><span class="comment">     *     on submission succeeded.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception which occurs during job execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> JobClient <span class="title function_">executeAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> executeAsync(getJobName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Triggers the program execution asynchronously. The environment will execute all parts of the</span></span><br><span class="line"><span class="comment">     * program that have resulted in a &quot;sink&quot; operation. Sink operations are for example printing</span></span><br><span class="line"><span class="comment">     * results or forwarding them to a message queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The program execution will be logged and displayed with the provided name</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName desired name of the job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> JobClient&#125; that can be used to communicate with the submitted job, completed</span></span><br><span class="line"><span class="comment">     *     on submission succeeded.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception which occurs during job execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> JobClient <span class="title function_">executeAsync</span><span class="params">(String jobName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> executeAsync(getStreamGraph(checkNotNull(jobName)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Triggers the program execution asynchronously. The environment will execute all parts of the</span></span><br><span class="line"><span class="comment">     * program that have resulted in a &quot;sink&quot; operation. Sink operations are for example printing</span></span><br><span class="line"><span class="comment">     * results or forwarding them to a message queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> streamGraph the stream graph representing the transformations</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> JobClient&#125; that can be used to communicate with the submitted job, completed</span></span><br><span class="line"><span class="comment">     *     on submission succeeded.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception which occurs during job execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> JobClient <span class="title function_">executeAsync</span><span class="params">(StreamGraph streamGraph)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        checkNotNull(streamGraph, <span class="string">&quot;StreamGraph cannot be null.&quot;</span>);</span><br><span class="line">        checkNotNull(</span><br><span class="line">                configuration.get(DeploymentOptions.TARGET),</span><br><span class="line">                <span class="string">&quot;No execution.target specified in your configuration file.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">PipelineExecutorFactory</span> <span class="variable">executorFactory</span> <span class="operator">=</span></span><br><span class="line">                executorServiceLoader.getExecutorFactory(configuration);</span><br><span class="line"></span><br><span class="line">        checkNotNull(</span><br><span class="line">                executorFactory,</span><br><span class="line">                <span class="string">&quot;Cannot find compatible factory for specified execution.target (=%s)&quot;</span>,</span><br><span class="line">                configuration.get(DeploymentOptions.TARGET));</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;JobClient&gt; jobClientFuture =</span><br><span class="line">                executorFactory</span><br><span class="line">                        .getExecutor(configuration)</span><br><span class="line">                        .execute(streamGraph, configuration, userClassloader);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">JobClient</span> <span class="variable">jobClient</span> <span class="operator">=</span> jobClientFuture.get();</span><br><span class="line">            jobListeners.forEach(jobListener -&gt; jobListener.onJobSubmitted(jobClient, <span class="literal">null</span>));</span><br><span class="line">            <span class="keyword">return</span> jobClient;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException executionException) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Throwable</span> <span class="variable">strippedException</span> <span class="operator">=</span></span><br><span class="line">                    ExceptionUtils.stripExecutionException(executionException);</span><br><span class="line">            jobListeners.forEach(</span><br><span class="line">                    jobListener -&gt; jobListener.onJobSubmitted(<span class="literal">null</span>, strippedException));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlinkException</span>(</span><br><span class="line">                    String.format(<span class="string">&quot;Failed to execute job &#x27;%s&#x27;.&quot;</span>, streamGraph.getJobName()),</span><br><span class="line">                    strippedException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Getter of the &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.graph.StreamGraph&#125; of the streaming job.</span></span><br><span class="line"><span class="comment">     * This call clears previously registered &#123;<span class="doctag">@link</span> Transformation transformations&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The streamgraph representing the transformations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> StreamGraph <span class="title function_">getStreamGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getStreamGraph(getJobName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Getter of the &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.graph.StreamGraph&#125; of the streaming job.</span></span><br><span class="line"><span class="comment">     * This call clears previously registered &#123;<span class="doctag">@link</span> Transformation transformations&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName Desired name of the job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The streamgraph representing the transformations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> StreamGraph <span class="title function_">getStreamGraph</span><span class="params">(String jobName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getStreamGraph(jobName, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Getter of the &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.graph.StreamGraph StreamGraph&#125; of the</span></span><br><span class="line"><span class="comment">     * streaming job with the option to clear previously registered &#123;<span class="doctag">@link</span> Transformation</span></span><br><span class="line"><span class="comment">     * transformations&#125;. Clearing the transformations allows, for example, to not re-execute the</span></span><br><span class="line"><span class="comment">     * same operations when calling &#123;<span class="doctag">@link</span> #execute()&#125; multiple times.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName Desired name of the job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clearTransformations Whether or not to clear previously registered transformations</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The streamgraph representing the transformations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> StreamGraph <span class="title function_">getStreamGraph</span><span class="params">(String jobName, <span class="type">boolean</span> clearTransformations)</span> &#123;</span><br><span class="line">        <span class="type">StreamGraph</span> <span class="variable">streamGraph</span> <span class="operator">=</span> getStreamGraphGenerator().setJobName(jobName).generate();</span><br><span class="line">        <span class="keyword">if</span> (clearTransformations) &#123;</span><br><span class="line">            <span class="built_in">this</span>.transformations.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> streamGraph;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StreamGraphGenerator <span class="title function_">getStreamGraphGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (transformations.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    <span class="string">&quot;No operators defined in streaming topology. Cannot execute.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RuntimeExecutionMode</span> <span class="variable">executionMode</span> <span class="operator">=</span> configuration.get(ExecutionOptions.RUNTIME_MODE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StreamGraphGenerator</span>(transformations, config, checkpointCfg, getConfiguration())</span><br><span class="line">                .setRuntimeExecutionMode(executionMode)</span><br><span class="line">                .setStateBackend(defaultStateBackend)</span><br><span class="line">                .setSavepointDir(defaultSavepointDirectory)</span><br><span class="line">                .setChaining(isChainingEnabled)</span><br><span class="line">                .setUserArtifacts(cacheFile)</span><br><span class="line">                .setTimeCharacteristic(timeCharacteristic)</span><br><span class="line">                .setDefaultBufferTimeout(bufferTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates the plan with which the system will execute the program, and returns it as a String</span></span><br><span class="line"><span class="comment">     * using a JSON representation of the execution data flow graph. Note that this needs to be</span></span><br><span class="line"><span class="comment">     * called, before the plan is executed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The execution plan of the program, as a JSON String.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getExecutionPlan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getStreamGraph(getJobName(), <span class="literal">false</span>).getStreamingPlanAsJSON();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &quot;closure-cleaned&quot; version of the given function. Cleans only if closure cleaning is</span></span><br><span class="line"><span class="comment">     * not disabled in the &#123;<span class="doctag">@link</span> org.apache.flink.api.common.ExecutionConfig&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> &lt;F&gt; F <span class="title function_">clean</span><span class="params">(F f)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getConfig().isClosureCleanerEnabled()) &#123;</span><br><span class="line">            ClosureCleaner.clean(f, getConfig().getClosureCleanerLevel(), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ClosureCleaner.ensureSerializable(f);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds an operator to the list of operators that should be executed when calling &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #execute&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;When calling &#123;<span class="doctag">@link</span> #execute()&#125; only the operators that where previously added to the list</span></span><br><span class="line"><span class="comment">     * are executed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This is not meant to be used by users. The API methods that create operators must call</span></span><br><span class="line"><span class="comment">     * this method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOperator</span><span class="params">(Transformation&lt;?&gt; transformation)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(transformation, <span class="string">&quot;transformation must not be null.&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.transformations.add(transformation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Factory methods for ExecutionEnvironments</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an execution environment that represents the context in which the program is</span></span><br><span class="line"><span class="comment">     * currently executed. If the program is invoked standalone, this method returns a local</span></span><br><span class="line"><span class="comment">     * execution environment, as returned by &#123;<span class="doctag">@link</span> #createLocalEnvironment()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The execution environment of the context in which the program is executed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title function_">getExecutionEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getExecutionEnvironment(<span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an execution environment that represents the context in which the program is</span></span><br><span class="line"><span class="comment">     * currently executed. If the program is invoked standalone, this method returns a local</span></span><br><span class="line"><span class="comment">     * execution environment, as returned by &#123;<span class="doctag">@link</span> #createLocalEnvironment(Configuration)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;When executed from the command line the given configuration is stacked on top of the</span></span><br><span class="line"><span class="comment">     * global configuration which comes from the &#123;<span class="doctag">@code</span> flink-conf.yaml&#125;, potentially overriding</span></span><br><span class="line"><span class="comment">     * duplicated options.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration The configuration to instantiate the environment with.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The execution environment of the context in which the program is executed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title function_">getExecutionEnvironment</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Utils.resolveFactory(threadLocalContextEnvironmentFactory, contextEnvironmentFactory)</span><br><span class="line">                .map(factory -&gt; factory.createExecutionEnvironment(configuration))</span><br><span class="line">                .orElseGet(() -&gt; StreamExecutionEnvironment.createLocalEnvironment(configuration));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> LocalStreamEnvironment&#125;. The local execution environment will run the</span></span><br><span class="line"><span class="comment">     * program in a multi-threaded fashion in the same JVM as the environment was created in. The</span></span><br><span class="line"><span class="comment">     * default parallelism of the local environment is the number of hardware contexts (CPU cores /</span></span><br><span class="line"><span class="comment">     * threads), unless it was specified differently by &#123;<span class="doctag">@link</span> #setParallelism(int)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A local execution environment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalStreamEnvironment <span class="title function_">createLocalEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createLocalEnvironment(defaultLocalParallelism);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> LocalStreamEnvironment&#125;. The local execution environment will run the</span></span><br><span class="line"><span class="comment">     * program in a multi-threaded fashion in the same JVM as the environment was created in. It</span></span><br><span class="line"><span class="comment">     * will use the parallelism specified in the parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parallelism The parallelism for the local environment.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A local execution environment with the specified parallelism.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalStreamEnvironment <span class="title function_">createLocalEnvironment</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createLocalEnvironment(parallelism, <span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> LocalStreamEnvironment&#125;. The local execution environment will run the</span></span><br><span class="line"><span class="comment">     * program in a multi-threaded fashion in the same JVM as the environment was created in. It</span></span><br><span class="line"><span class="comment">     * will use the parallelism specified in the parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parallelism The parallelism for the local environment.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration Pass a custom configuration into the cluster</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A local execution environment with the specified parallelism.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalStreamEnvironment <span class="title function_">createLocalEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="type">int</span> parallelism, Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">copyOfConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        copyOfConfiguration.addAll(configuration);</span><br><span class="line">        copyOfConfiguration.set(CoreOptions.DEFAULT_PARALLELISM, parallelism);</span><br><span class="line">        <span class="keyword">return</span> createLocalEnvironment(copyOfConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> LocalStreamEnvironment&#125;. The local execution environment will run the</span></span><br><span class="line"><span class="comment">     * program in a multi-threaded fashion in the same JVM as the environment was created in.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration Pass a custom configuration into the cluster</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A local execution environment with the specified parallelism.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalStreamEnvironment <span class="title function_">createLocalEnvironment</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (configuration.getOptional(CoreOptions.DEFAULT_PARALLELISM).isPresent()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalStreamEnvironment</span>(configuration);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Configuration</span> <span class="variable">copyOfConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">            copyOfConfiguration.addAll(configuration);</span><br><span class="line">            copyOfConfiguration.set(CoreOptions.DEFAULT_PARALLELISM, defaultLocalParallelism);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalStreamEnvironment</span>(copyOfConfiguration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> LocalStreamEnvironment&#125; for local program execution that also starts the web</span></span><br><span class="line"><span class="comment">     * monitoring UI.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The local execution environment will run the program in a multi-threaded fashion in the</span></span><br><span class="line"><span class="comment">     * same JVM as the environment was created in. It will use the parallelism specified in the</span></span><br><span class="line"><span class="comment">     * parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the configuration key &#x27;rest.port&#x27; was set in the configuration, that particular port</span></span><br><span class="line"><span class="comment">     * will be used for the web UI. Otherwise, the default port (8081) will be used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title function_">createLocalEnvironmentWithWebUI</span><span class="params">(Configuration conf)</span> &#123;</span><br><span class="line">        checkNotNull(conf, <span class="string">&quot;conf&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!conf.contains(RestOptions.PORT)) &#123;</span><br><span class="line">            <span class="comment">// explicitly set this option so that it&#x27;s not set to 0 later</span></span><br><span class="line">            conf.setInteger(RestOptions.PORT, RestOptions.PORT.defaultValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> createLocalEnvironment(conf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> RemoteStreamEnvironment&#125;. The remote environment sends (parts of) the</span></span><br><span class="line"><span class="comment">     * program to a cluster for execution. Note that all file paths used in the program must be</span></span><br><span class="line"><span class="comment">     * accessible from the cluster. The execution will use no parallelism, unless the parallelism is</span></span><br><span class="line"><span class="comment">     * set explicitly via &#123;<span class="doctag">@link</span> #setParallelism&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host The host name or address of the master (JobManager), where the program should be</span></span><br><span class="line"><span class="comment">     *     executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port of the master (JobManager), where the program should be executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jarFiles The JAR files with code that needs to be shipped to the cluster. If the</span></span><br><span class="line"><span class="comment">     *     program uses user-defined functions, user-defined input formats, or any libraries, those</span></span><br><span class="line"><span class="comment">     *     must be provided in the JAR files.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A remote environment that executes the program on a cluster.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title function_">createRemoteEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">            String host, <span class="type">int</span> port, String... jarFiles)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RemoteStreamEnvironment</span>(host, port, jarFiles);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> RemoteStreamEnvironment&#125;. The remote environment sends (parts of) the</span></span><br><span class="line"><span class="comment">     * program to a cluster for execution. Note that all file paths used in the program must be</span></span><br><span class="line"><span class="comment">     * accessible from the cluster. The execution will use the specified parallelism.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host The host name or address of the master (JobManager), where the program should be</span></span><br><span class="line"><span class="comment">     *     executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port of the master (JobManager), where the program should be executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parallelism The parallelism to use during the execution.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jarFiles The JAR files with code that needs to be shipped to the cluster. If the</span></span><br><span class="line"><span class="comment">     *     program uses user-defined functions, user-defined input formats, or any libraries, those</span></span><br><span class="line"><span class="comment">     *     must be provided in the JAR files.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A remote environment that executes the program on a cluster.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title function_">createRemoteEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">            String host, <span class="type">int</span> port, <span class="type">int</span> parallelism, String... jarFiles)</span> &#123;</span><br><span class="line">        <span class="type">RemoteStreamEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteStreamEnvironment</span>(host, port, jarFiles);</span><br><span class="line">        env.setParallelism(parallelism);</span><br><span class="line">        <span class="keyword">return</span> env;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> RemoteStreamEnvironment&#125;. The remote environment sends (parts of) the</span></span><br><span class="line"><span class="comment">     * program to a cluster for execution. Note that all file paths used in the program must be</span></span><br><span class="line"><span class="comment">     * accessible from the cluster. The execution will use the specified parallelism.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host The host name or address of the master (JobManager), where the program should be</span></span><br><span class="line"><span class="comment">     *     executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port of the master (JobManager), where the program should be executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientConfig The configuration used by the client that connects to the remote cluster.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jarFiles The JAR files with code that needs to be shipped to the cluster. If the</span></span><br><span class="line"><span class="comment">     *     program uses user-defined functions, user-defined input formats, or any libraries, those</span></span><br><span class="line"><span class="comment">     *     must be provided in the JAR files.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A remote environment that executes the program on a cluster.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title function_">createRemoteEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">            String host, <span class="type">int</span> port, Configuration clientConfig, String... jarFiles)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RemoteStreamEnvironment</span>(host, port, clientConfig, jarFiles);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the default parallelism that will be used for the local execution environment created by</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #createLocalEnvironment()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The default local parallelism</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDefaultLocalParallelism</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultLocalParallelism;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the default parallelism that will be used for the local execution environment created by</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #createLocalEnvironment()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parallelism The parallelism to use as the default local parallelism.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setDefaultLocalParallelism</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;</span><br><span class="line">        defaultLocalParallelism = parallelism;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Methods to control the context and local environments for execution from packaged programs</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initializeContextEnvironment</span><span class="params">(StreamExecutionEnvironmentFactory ctx)</span> &#123;</span><br><span class="line">        contextEnvironmentFactory = ctx;</span><br><span class="line">        threadLocalContextEnvironmentFactory.set(contextEnvironmentFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resetContextEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line">        contextEnvironmentFactory = <span class="literal">null</span>;</span><br><span class="line">        threadLocalContextEnvironmentFactory.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers a file at the distributed cache under the given name. The file will be accessible</span></span><br><span class="line"><span class="comment">     * from any user-defined function in the (distributed) runtime under a local path. Files may be</span></span><br><span class="line"><span class="comment">     * local files (which will be distributed via BlobServer), or files in a distributed file</span></span><br><span class="line"><span class="comment">     * system. The runtime will copy the files temporarily to a local cache, if needed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RuntimeContext&#125; can be obtained inside</span></span><br><span class="line"><span class="comment">     * UDFs via &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RichFunction#getRuntimeContext()&#125; and</span></span><br><span class="line"><span class="comment">     * provides access &#123;<span class="doctag">@link</span> org.apache.flink.api.common.cache.DistributedCache&#125; via &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.common.functions.RuntimeContext#getDistributedCache()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g. &quot;file:///some/path&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/and/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name The name under which the file is registered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerCachedFile</span><span class="params">(String filePath, String name)</span> &#123;</span><br><span class="line">        registerCachedFile(filePath, name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers a file at the distributed cache under the given name. The file will be accessible</span></span><br><span class="line"><span class="comment">     * from any user-defined function in the (distributed) runtime under a local path. Files may be</span></span><br><span class="line"><span class="comment">     * local files (which will be distributed via BlobServer), or files in a distributed file</span></span><br><span class="line"><span class="comment">     * system. The runtime will copy the files temporarily to a local cache, if needed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RuntimeContext&#125; can be obtained inside</span></span><br><span class="line"><span class="comment">     * UDFs via &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RichFunction#getRuntimeContext()&#125; and</span></span><br><span class="line"><span class="comment">     * provides access &#123;<span class="doctag">@link</span> org.apache.flink.api.common.cache.DistributedCache&#125; via &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.common.functions.RuntimeContext#getDistributedCache()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g. &quot;file:///some/path&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/and/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name The name under which the file is registered.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executable flag indicating whether the file should be executable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerCachedFile</span><span class="params">(String filePath, String name, <span class="type">boolean</span> executable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheFile.add(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(</span><br><span class="line">                        name, <span class="keyword">new</span> <span class="title class_">DistributedCache</span>.DistributedCacheEntry(filePath, executable)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Private helpers.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> &lt;OUT, T <span class="keyword">extends</span> <span class="title class_">TypeInformation</span>&lt;OUT&gt;&gt; T <span class="title function_">getTypeInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">            Object source,</span></span><br><span class="line"><span class="params">            String sourceName,</span></span><br><span class="line"><span class="params">            Class&lt;?&gt; baseSourceClass,</span></span><br><span class="line"><span class="params">            TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        TypeInformation&lt;OUT&gt; resolvedTypeInfo = typeInfo;</span><br><span class="line">        <span class="keyword">if</span> (resolvedTypeInfo == <span class="literal">null</span> &amp;&amp; source <span class="keyword">instanceof</span> ResultTypeQueryable) &#123;</span><br><span class="line">            resolvedTypeInfo = ((ResultTypeQueryable&lt;OUT&gt;) source).getProducedType();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolvedTypeInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resolvedTypeInfo =</span><br><span class="line">                        TypeExtractor.createTypeInfo(</span><br><span class="line">                                baseSourceClass, source.getClass(), <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InvalidTypesException e) &#123;</span><br><span class="line">                resolvedTypeInfo = (TypeInformation&lt;OUT&gt;) <span class="keyword">new</span> <span class="title class_">MissingTypeInfo</span>(sourceName, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) resolvedTypeInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getJobName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configuration.getString(PipelineOptions.NAME, DEFAULT_JOB_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
