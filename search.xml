<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/08/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>信息系统分析与设计初学笔记</title>
    <url>/2024/01/06/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>本文为读书【《信息系统分析与设计》 — 王晓敏 】的关键知识笔记</p>
</blockquote>
<h2 id="先行知识"><a href="#先行知识" class="headerlink" title="先行知识"></a>先行知识</h2><h3 id="数据、信息、知识、智慧定义"><a href="#数据、信息、知识、智慧定义" class="headerlink" title="数据、信息、知识、智慧定义"></a>数据、信息、知识、智慧定义</h3><blockquote>
<p>P22</p>
</blockquote>
<ul>
<li><p>数据：是一组表示数量、行为和目标的可鉴别的非随机符号。它可以是字母、数字或其他符号，也可以是图形、图像、声音等。是信息系统的原材料。</p>
</li>
<li><p>信息：是经过加工后的数据，它对接收者有用，对决策或行为有现实或潜在的价值。信息具有以下特征：</p>
<ol>
<li>事实性：是信息的最基本属性，记录真实的事件或事件数据；</li>
<li>扩散性：是信息的本性。信息浓度越大，扩散性越强；</li>
<li>传输性：可以通过各种手段传输到很远的地方；</li>
<li>共享性：信息可以共享但不能交换，不会因为某人获得了信息而使其他人的信息减少；</li>
<li>增值性：在某一目的下，随着时间、数量粒度上不断增加的信息，具有增值性。比如用过去天气信息预测未来；</li>
<li>不完全性：客观事实的知识不可能完全得到；</li>
<li>等级性：不同级别的管理者对同一事物所需的信息是不同的，故信息也分等级，一般分为战略级、战术级、作业级；</li>
<li>滞后性：数据经过加工后才可能成为信息，利用信息决策才能产生结果。中间的时间间隔总不为零，故具有滞后；</li>
</ol>
</li>
<li><p>知识：是一种特定的信息，通过语言、文字、图片等形式表现出来，具有信息的一切数据，属于信息的范畴。</p>
</li>
<li><p>智慧：代表着人们辨析、判断和发明创造的能力。是知识和信息经过人类大脑内化后转换为对事务理解和处理的能力，具有明智决策、促进活动高效顺利完成的特征。</p>
</li>
</ul>
<img src="/2024/01/06/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/image-20240106132526565.png" class="" title="image-20240106132526565">

<h3 id="信息与管理"><a href="#信息与管理" class="headerlink" title="信息与管理"></a>信息与管理</h3><blockquote>
<p>P24</p>
</blockquote>
<p>信息在管理过程起着基础性的作用，下面从管理职能的角度分析：</p>
<ol>
<li>信息是制定计划的基本依据：拥有信息的质量决定计划的质量。例如利用过去、现在的实际信息，反应未来的趋势；</li>
<li>信息是组织实施的保证：具体的信息作为前提条件，才能保证活动的顺利进行。例如拥有具体的信息才能合理设置机构、配备人员、调动财力；</li>
<li>信息是调节控制的指示器：通过反映系统运行状态的检测信息，通过调节实际的参数来接近目标；</li>
<li>信息是激励职工的依据：职工的奖惩需要度量职工业绩的信息；</li>
<li>信息是领导指挥的基础：领导者需要掌握组织的全面信息</li>
</ol>
<h3 id="不同管理层的信息区别"><a href="#不同管理层的信息区别" class="headerlink" title="不同管理层的信息区别"></a>不同管理层的信息区别</h3><blockquote>
<p>P25</p>
</blockquote>
<p>分为：</p>
<p>战略信息：供高层管理人员进行战略决策时用。</p>
<p>战术信息：供中层管理人员完成计划、资源分配用。</p>
<p>业务信息：供基层业务人员和管理人员执行已指定计划、组织生产或服务活动时用。</p>
<h2 id="信息系统的定义"><a href="#信息系统的定义" class="headerlink" title="信息系统的定义"></a>信息系统的定义</h2><p>Gondon B.Davis: 是一个利用计算机硬件和软件，手工作业，分析，计划，控制和决策模型以及数据库的人机系统，它能提供信息，支持企业或组织的运行、管理和决策功能。</p>
<p>信息系统：是结合管理理论和方法，应用信息技术解决管理问题，为管理决策提供支持的系统。</p>
<h2 id="信息系统的功能"><a href="#信息系统的功能" class="headerlink" title="信息系统的功能"></a>信息系统的功能</h2><p>信息系统具有数据的采集和输入、传输、存储、处理、输出等基本功能。</p>
<h2 id="信息系统的结构"><a href="#信息系统的结构" class="headerlink" title="信息系统的结构"></a>信息系统的结构</h2><h3 id="概念结构"><a href="#概念结构" class="headerlink" title="概念结构"></a>概念结构</h3><img src="/2024/01/06/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/image-20240106093835136-1704520584638-5.png" class="" title="image-20240106093835136">



<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>拆分子系统并提供该子系统功能对应的信息</p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>集中式： 主机-终端（host-terminal）系统</p>
<p>分布式：文件服务器，传统客户机-服务器（client-server，C&#x2F;S），浏览器-服务器（browser&#x2F;server，B&#x2F;S），服务器集群，云计算</p>
<h2 id="信息系统的分类"><a href="#信息系统的分类" class="headerlink" title="信息系统的分类"></a>信息系统的分类</h2><p>按照技术发展来对信息系统进行分类结合了时间和技术两个维度，一般认为信息系统的发展已经经历了数据处理系统、管理信息系统、决策支持系统、主管支持系统、商务智能系统、人工智能系统六个阶段。（P37）</p>
<p>由以上介绍可知，信息系统的技术是从解决结构化问题逐步向解决半结构化和非结构化问题发展的。</p>
<h2 id="信息系统与组织"><a href="#信息系统与组织" class="headerlink" title="信息系统与组织"></a>信息系统与组织</h2><p>信息、管理和信息系统三者的关系可以这样理解：信息是主体，管理是目的，信息系统是手段。信息、管理和信息系统三者的关系可以这样理解：信息反应了组织内部和外部相关组织的各种资源、关系和活动状态；管理是组织利用信息从事协调、控制以达成组织目标的活动过程；信息系统是对组织管理职能的技术支持系统</p>
<h2 id="信息系统建设"><a href="#信息系统建设" class="headerlink" title="信息系统建设"></a>信息系统建设</h2><blockquote>
<p>P51</p>
</blockquote>
<h3 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h3><p>由于信息系统的多学科性、综合性，建设周期长、投资大、风险大，比一般的技术工程有更大的难度和复杂度。</p>
<h3 id="系统方法的应用"><a href="#系统方法的应用" class="headerlink" title="系统方法的应用"></a>系统方法的应用</h3><blockquote>
<p>P54</p>
</blockquote>
<ol>
<li>还原论与整体论相结合：进行系统分解时，各个部分是相对独立而不是孤立的<ul>
<li>还原论：将系统分解为若干部分相对独立的子系统，通过研究清楚子系统就可以获得整个系统的性质；</li>
<li>整体论：将系统分解为若干部分研究，但不是将整体看作是各个部分的简单叠加，即整体大于部分之和</li>
</ul>
</li>
<li>微观分析和宏观综合相结合：微观描述过度到整体宏观描述<ul>
<li>微观分析：了解系统的层次结构</li>
<li>宏观综合：了解系统的功能结构及形成过程</li>
</ul>
</li>
<li>定性判断和定量计算相结合：<ul>
<li>定性判断：通过定性分析，建立信息系统总体及子系统的概念模型，再尽可能将它们转化为数学模型或计算机模型</li>
<li>定量计算：计算机擅长定量计算</li>
</ul>
</li>
<li>严格生命周期阶段与反复迭代相结合：开发过程既要强调不同阶段任务的严格划分，同时也允许不断修正和迭代</li>
</ol>
<h3 id="系统建模"><a href="#系统建模" class="headerlink" title="系统建模"></a>系统建模</h3><p>定义：系统建模是指以某种确定的形式（如文字、符号、图标、数学公式等），对系统某一方面本质属性的描述。是研究复杂系统问题的基本手段</p>
<p>目的：</p>
<ol>
<li>对复杂问题进行简化描述，帮助有关人员简单、直观、准确地了解系统本质；</li>
<li>统一的交流工具：各阶段产生的模型为后续阶段的有关人员提供工作依据；为项目验收和将来的维护工作提供文档依据；</li>
<li>利用工具将模型映射为特定平台的可执行代码，减少开发人员的工作量；</li>
</ol>
<h3 id="生命周期（开发分为哪几个阶段）"><a href="#生命周期（开发分为哪几个阶段）" class="headerlink" title="生命周期（开发分为哪几个阶段）"></a>生命周期（开发分为哪几个阶段）</h3><blockquote>
<p>P61</p>
</blockquote>
<p>信息系统的生命周期可以分为五个阶段：</p>
<ol>
<li>系统规划：对企业的环境、目标及现行系统的状况进行初步调查，根据目标和发展战略，分析将建设的信息系统的必要性和可能性，并对需求做出分析与预测。输出可行性分析报告、<strong>系统设计任务书</strong></li>
<li>系统分析：根据系统设计任务书、业务流程，提出新系统的逻辑模型（逻辑设计阶段），这也是与一般工程项目的重要区别。确定功能并输出<strong>系统说明书</strong>（系统设计和将来验收的的依据）</li>
<li>系统设计：根据系统说明书、实际条件，输出技术方案（物理设计阶段），输出<strong>系统设计说明书</strong></li>
<li>系统实施：根据系统设计说明书，分阶段生成实施计划（如购置、安装、调试计算机设备，编写和调试程序，系统测试，系统交付等）</li>
<li>系统运维与管理 ：系统投入使用后，需要经常进行运行记录、维护、变更、审计等，记录系统的运行情况，并进行必要的修改，评价系统的工作质量和经济效益</li>
</ol>
<h3 id="基于生命周期的开发方法"><a href="#基于生命周期的开发方法" class="headerlink" title="基于生命周期的开发方法"></a>基于生命周期的开发方法</h3><p>开发方法有以下：</p>
<table>
<thead>
<tr>
<th></th>
<th>说明</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>瀑布开发方法</td>
<td>确定各阶段的开始和结束时间，按照阶段逐步执行，并不允许回到上一阶段</td>
<td>简单、易操作，迫使开发人员遵循规范的方法和步骤，一定程序保障系统质量</td>
<td>系统推迟会带来风险，如果在开发周期晚期时发现大的错误，对工程的进度会操作严重影响</td>
<td>适合需求相对稳定、明确定义且变更少的项目。适用于小型项目或者需求变化不频繁的传统项目</td>
</tr>
<tr>
<td>原型开发方法</td>
<td>再投入大量资源开发前，用最经济的方法构造一个系统原型，尽早发现问题并完善原型</td>
<td>降低开发风险，尽早验证系统架构和关键算法。增进用户和开发人员沟通，用户提前接触到原型，可以提出更清楚的建议和意见。</td>
<td>不够成熟和便于管理。修改过程容易偏离原型的目的。用户容易以为原型即为交付的产品，损害质量</td>
<td>适合对需求不明确、需要快速验证概念或与用户频繁互动的项目。特别适用于用户体验设计和软件界面的开发。</td>
</tr>
<tr>
<td>迭代开发法</td>
<td>增量迭代：将整个系统划分为多个小型的的、功能相对独立的小项目。通过不断实现小项目从而实现完整功能<br />进化迭代：每次迭代是上一次的演化和完善</td>
<td>不同技术人员可以并行开发，每次迭代的经验可以与下次迭代结合，提高质量，降低开发成本</td>
<td>需要经验丰富的架构师</td>
<td>适用于需求相对明确但可以分阶段完成的项目。项目可以分成多个迭代，在每个迭代中增加新功能或修复问题。</td>
</tr>
<tr>
<td>螺旋开发方法</td>
<td>每个迭代周期加入风险分析</td>
<td></td>
<td></td>
<td>适用于需要持续风险管理和评估的复杂项目，尤其是安全性和风险敏感度高的项目。适用于长期项目，需要不断演进和改进的情况。</td>
</tr>
<tr>
<td>敏捷开发-Scrum</td>
<td><strong>产品Backlog创建：</strong> 将所有需求以用户故事或任务的形式列在产品Backlog中。 <br /><strong>Sprint计划会议：</strong> 团队在每个Sprint开始前开会，选择并承诺要在Sprint期间完成的Backlog条目。<br /> <strong>Sprint周期：</strong> 团队根据计划进行工作，通常持续2至4周。 <br /><strong>日常Scrum会议：</strong> 团队每天开会，分享进展、问题和计划。 <br /><strong>Sprint评审会议：</strong> 每个Sprint结束时，团队向利益相关者演示完成的工作。|<br /> <strong>Sprint回顾会议：</strong> 团队回顾Sprint，探讨如何改进工作流程。</td>
<td><strong>灵活性：</strong> 允许适应变化，快速响应需求变化和用户反馈。 <br /><strong>可见性和透明度：</strong> 团队通过日常会议和评审增强了对项目进度和问题的透明度。 <br /><strong>客户参与：</strong> 客户或利益相关者在每个Sprint结束时都能看到可工作的产品原型，有助于及时反馈。 <br /><strong>团队合作和责任：</strong> 强调团队合作和自我管理，每个团队成员都有明确的角色和责任。</td>
<td><strong>难以定义需求：</strong> 如果产品需求变动频繁，可能导致难以稳定的产品Backlog。 <br /><strong>依赖团队协作：</strong> 如果团队成员沟通或合作不佳，可能会影响整个Sprint的进展。 <br /><strong>不适用于所有项目：</strong> 对于某些项目类型（例如需求稳定的项目或团队分布在不同地理位置），Scrum可能不是最佳选择。<br /> <strong>需要经验丰富的团队：</strong> 对Scrum框架和流程的有效应用需要团队对敏捷开发有较高的了解和实践经验。</td>
<td>适用于需求变化频繁、对快速交付和持续改进有要求的项目。特别适用于需要快速响应市场变化或者有创新需求的项目。</td>
</tr>
</tbody></table>
<img src="/2024/01/06/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/image-20240107175849413.png" class="" title="image-20240107175849413">

<h3 id="基于开发技术的开发方法"><a href="#基于开发技术的开发方法" class="headerlink" title="基于开发技术的开发方法"></a>基于开发技术的开发方法</h3><ol>
<li>结构化开发方法</li>
<li>面相对象开发方法</li>
<li>面向服务开发方法：SOA和微服务</li>
</ol>
<p>SOA（面向服务的架构）和微服务都是用于构建和组织软件系统的架构风格，它们的主要区别在于以下几个方面：</p>
<h4 id="1-规模和粒度："><a href="#1-规模和粒度：" class="headerlink" title="1. 规模和粒度："></a>1. <strong>规模和粒度：</strong></h4><ul>
<li><strong>SOA：</strong> 面向服务的架构通常更倾向于较大的、粗粒度的服务。服务可能更大、更全面，其边界可能跨越多个业务领域或功能。</li>
<li><strong>微服务：</strong> 微服务更倾向于小型、精细粒度的服务。它们专注于特定的业务功能，并且是相对较小且自治的服务单元。</li>
</ul>
<h4 id="2-依赖关系："><a href="#2-依赖关系：" class="headerlink" title="2. 依赖关系："></a>2. <strong>依赖关系：</strong></h4><ul>
<li><strong>SOA：</strong> 服务之间的依赖可能更为紧密，有时一个服务可能依赖于多个其他服务。SOA服务可能在设计上更加灵活，但它们的集成可能需要更多的协调。</li>
<li><strong>微服务：</strong> 微服务强调独立性和自治性，每个服务尽可能减少对其他服务的依赖，有自己的数据存储和业务逻辑。这种松耦合性使得微服务更容易进行独立部署和扩展。</li>
</ul>
<h4 id="3-部署和管理："><a href="#3-部署和管理：" class="headerlink" title="3. 部署和管理："></a>3. <strong>部署和管理：</strong></h4><ul>
<li><strong>SOA：</strong> SOA服务通常更集中地部署和管理。这意味着更多的集中式治理和管理方式，可能对整体系统的控制更强。</li>
<li><strong>微服务：</strong> 微服务强调分散式部署和自治。每个微服务可以由独立的团队开发、部署和扩展，这使得微服务在敏捷性和快速创新方面具有优势。</li>
</ul>
<h4 id="4-技术栈和通信方式："><a href="#4-技术栈和通信方式：" class="headerlink" title="4. 技术栈和通信方式："></a>4. <strong>技术栈和通信方式：</strong></h4><ul>
<li><strong>SOA：</strong> SOA并没有限制使用特定的技术栈或通信协议，可以使用不同的技术和协议来实现服务间通信。</li>
<li><strong>微服务：</strong> 微服务通常更倾向于采用轻量级通信协议，比如HTTP&#x2F;REST或者消息队列，以及各种云原生技术栈，如Docker、Kubernetes等。</li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>SOA和微服务都是面向服务的架构，但它们在服务粒度、依赖关系、部署管理方式和技术栈等方面有所不同。微服务更加强调独立性、自治性和松耦合，适合于需要灵活性和快速创新的场景。而SOA在一些更大规模、集中式治理的场景中仍然发挥作用，尤其是在传统企业级系统中。</p>
<h3 id="系统开发的组织管理"><a href="#系统开发的组织管理" class="headerlink" title="系统开发的组织管理"></a>系统开发的组织管理</h3><h4 id="基础条件："><a href="#基础条件：" class="headerlink" title="基础条件："></a>基础条件：</h4><ol>
<li>领导重视，业务人员积极性高</li>
<li>有一定的科学管理基础</li>
<li>能组织一支具有不同层次的技术队伍</li>
<li>具备一定的资源</li>
</ol>
<h4 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h4><p>领导重视并参与，建设信息化委员会，下设项目管理办公室、各部门联络人。开发各阶段都需要业务人员参加配合</p>
<h4 id="选择开发方式"><a href="#选择开发方式" class="headerlink" title="选择开发方式"></a>选择开发方式</h4><h4 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h4><ol>
<li>进度管理与控制：甘特图</li>
<li>经费管理：测算信息系统的成本、制定经费计划和成本计划的变更控制</li>
<li>质量管理：用户满意度调查</li>
<li>文档管理：文档作为信息系统的生命线，编写文档需要规范化、标准化、维护文档的一致性、可追踪性</li>
</ol>
<h2 id="信息系统建设-系统规划"><a href="#信息系统建设-系统规划" class="headerlink" title="信息系统建设 - 系统规划"></a>信息系统建设 - 系统规划</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol>
<li>制定信息系统的发展战略<br>调查企业目标和发展战略，评价现行信息系统的功能和应用情况，在此基础上确定信息系统的使命，制定战略目标</li>
<li>制定信息系统的总体方案，安排项目开发计划</li>
<li>制定系统建设的资源分配计划</li>
</ol>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>系统规划是面相全局、长远的关键问题，具有较强的不确定性，结构化程度较低</li>
<li>系统规划是高层次的系统分析，高层管理人员是主体</li>
<li>不宜过细，不是解决系统开发中的具体问题。要起到指导作用</li>
<li>是企业规划的一部分，随环境发展而变化</li>
</ol>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol>
<li>支持企业的总目标</li>
<li>整体上着眼于高层管理，兼顾各管理层的要求</li>
<li>摆脱信息系统对组织机构的依从性</li>
<li>使系统具有良好的整体性<br>自顶向下规划，自底向上实现</li>
<li>便于实施</li>
</ol>
<h3 id="系统规划的技术和方法"><a href="#系统规划的技术和方法" class="headerlink" title="系统规划的技术和方法"></a>系统规划的技术和方法</h3><h4 id="战略目标集转移法（Strategy-Set-Transformation，-SST）"><a href="#战略目标集转移法（Strategy-Set-Transformation，-SST）" class="headerlink" title="战略目标集转移法（Strategy Set Transformation， SST）"></a>战略目标集转移法（Strategy Set Transformation， SST）</h4><ol>
<li>组织战略集：<br>组织本身战略规划过程的产物，包括组织的使命、目标、战略和其他一些与信息系统有关的组织属性</li>
<li>信息系统战略集：<br>由系统目标、系统约束和系统开发战略构成</li>
<li>信息系统战略规划过程：<br>从“组织战略集”向“信息系统战略集”转化的过程，可以分为三步：1）划出组织利益相关方的结构；2）确定利益相关方的要求；3）定义组织相对于每个利益相关方的任务和战略</li>
<li>进一步解释和验证组织战略集</li>
</ol>
<h4 id="企业系统规划法（Business-System-Planning，-BSP）"><a href="#企业系统规划法（Business-System-Planning，-BSP）" class="headerlink" title="企业系统规划法（Business System Planning， BSP）"></a>企业系统规划法（Business System Planning， BSP）</h4><p>早期规划方法，对于现代信息系统，其理论具有借鉴价值，需要寻找新的规划方法和手段。</p>
<h4 id="关键成功因素法（Key-Successful-Factor，-KSF）"><a href="#关键成功因素法（Key-Successful-Factor，-KSF）" class="headerlink" title="关键成功因素法（Key Successful Factor， KSF）"></a>关键成功因素法（Key Successful Factor， KSF）</h4><ol>
<li>确定组织目标：<br>可以从以下四个方面展开：市场目标、创新目标、盈利目标和社会目标</li>
<li>确定关键成功因素：<br>分析影响具体目标的核心因素</li>
<li>确定管家能成功因素的性能指标：<br>即KPI，通常控制在3个以内</li>
<li>确定信息需求</li>
</ol>
<h4 id="价值链分析法（Value-Chain-Analysis，-VCA）"><a href="#价值链分析法（Value-Chain-Analysis，-VCA）" class="headerlink" title="价值链分析法（Value Chain Analysis， VCA）"></a>价值链分析法（Value Chain Analysis， VCA）</h4><ol>
<li>识别企业价值链：<br>基本价值：直接参与研发、制造或销售企业产品和服务的活动，它们构成企业一个完整的从产品创建直到顾客完成消费的价值链。缺少任何一个环节都不能达到最终产品或服务的目的；<br>支持价值：为公司整体提供支持，用以保证基本价值过程的顺利进行，不能归入到基本价值过程中的某个环节</li>
<li>确定关键价值增加环节：<br>通过调查（客户问卷或者专家）确定对顾客来说最明显、最显著的增加价值的环节</li>
<li>确定关键价值减少环节：<br>同2，不过这会是减少</li>
<li>明确信息技术对关键价值环节的支持：<br>确定支持上面2、3的环节的信息技术和信息系统</li>
</ol>
<h3 id="信息系统战略规划的基本步骤"><a href="#信息系统战略规划的基本步骤" class="headerlink" title="信息系统战略规划的基本步骤"></a>信息系统战略规划的基本步骤</h3><ol>
<li><p>环境准备</p>
</li>
<li><p>规划步骤<br>企业调查和分析、信息系统调查和分析、制定方向、评审及建议</p>
<img src="/2024/01/06/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/565493510d2543f67dccb27283d65cb.jpg" class="" title="565493510d2543f67dccb27283d65cb">
<img src="/2024/01/06/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/1929c60108f5f666acf910a770fbb53.jpg" class="" title="1929c60108f5f666acf910a770fbb53">

<img src="/2024/01/06/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/a409bd8668beffc8d05d5655934be4b.jpg" class="" title="a409bd8668beffc8d05d5655934be4b"></li>
</ol>
<h3 id="可行性论证"><a href="#可行性论证" class="headerlink" title="可行性论证"></a>可行性论证</h3><ol>
<li>技术可行性</li>
<li>经济可行性</li>
<li>社会可行性</li>
</ol>
<p>输出可行性分析报告</p>
]]></content>
      <tags>
        <tag>信息系统</tag>
      </tags>
  </entry>
  <entry>
    <title>test_post_image</title>
    <url>/2023/12/18/test-post-image/</url>
    <content><![CDATA[<img src="/2023/12/18/test-post-image/image-20231218222304297.png" class="" title="image-20231218222304297">

<img src="/2023/12/18/test-post-image/RE4wppa.jpg" class="" title="RE4wppa">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"> * contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"> * this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"> * The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"> * (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"> * the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.apache.flink.streaming.api.environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.annotation.Experimental;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.annotation.Internal;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.annotation.Public;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.annotation.PublicEvolving;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.ExecutionConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.InvalidProgramException;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.JobExecutionResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.RuntimeExecutionMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.cache.DistributedCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.InvalidTypesException;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.io.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.io.FilePathFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.io.InputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.restartstrategy.RestartStrategies;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.BasicTypeInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.TypeInformation;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.connector.source.Boundedness;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.connector.source.Source;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.connector.source.lib.NumberSequenceSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.dag.Transformation;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.ClosureCleaner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.Utils;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.io.TextInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple3;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.typeutils.MissingTypeInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.typeutils.PojoTypeInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.typeutils.ResultTypeQueryable;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.typeutils.TypeExtractor;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.CoreOptions;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.DeploymentOptions;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.ExecutionOptions;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.PipelineOptions;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.ReadableConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.RestOptions;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.DefaultExecutorServiceLoader;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.DetachedJobExecutionResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.JobClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.JobListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.PipelineExecutor;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.PipelineExecutorFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.PipelineExecutorServiceLoader;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.runtime.state.KeyGroupRangeAssignment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.runtime.state.StateBackend;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.runtime.state.StateBackendLoader;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.CheckpointingMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.TimeCharacteristic;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.ContinuousFileMonitoringFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.ContinuousFileReaderOperatorFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.FileMonitoringFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.FileProcessingMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.FileReadFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.FromElementsFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.FromIteratorFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.FromSplittableIteratorFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.InputFormatSourceFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.ParallelSourceFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.SocketTextStreamFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.SourceFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.StatefulSequenceSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.TimestampedFileInputSplit;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.graph.StreamGraph;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.graph.StreamGraphGenerator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.operators.StreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.DynamicCodeLoadingException;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.ExceptionUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.FlinkException;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.InstantiationUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Preconditions;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.SplittableIterator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.WrappingRuntimeException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Serializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.flink.util.Preconditions.checkNotNull;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The StreamExecutionEnvironment is the context in which a streaming program is executed. A &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * LocalStreamEnvironment&#125; will cause execution in the current JVM, a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * RemoteStreamEnvironment&#125; will cause execution on a remote setup.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The environment provides methods to control the job execution (such as setting the parallelism</span></span><br><span class="line"><span class="comment"> * or the fault tolerance/checkpointing parameters) and to interact with the outside world (data</span></span><br><span class="line"><span class="comment"> * access).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.apache.flink.streaming.api.environment.LocalStreamEnvironment</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.apache.flink.streaming.api.environment.RemoteStreamEnvironment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExecutionEnvironment</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The default name to use for a streaming job if no other name has been specified. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_JOB_NAME</span> <span class="operator">=</span> <span class="string">&quot;Flink Streaming Job&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The time characteristic that is used if none other is set. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">TimeCharacteristic</span> <span class="variable">DEFAULT_TIME_CHARACTERISTIC</span> <span class="operator">=</span></span><br><span class="line">            TimeCharacteristic.EventTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The environment of the context (local by default, cluster if invoked through command line).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StreamExecutionEnvironmentFactory</span> <span class="variable">contextEnvironmentFactory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The ThreadLocal used to store &#123;<span class="doctag">@link</span> StreamExecutionEnvironmentFactory&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;StreamExecutionEnvironmentFactory&gt;</span><br><span class="line">            threadLocalContextEnvironmentFactory = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The default parallelism used when creating a local environment. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">defaultLocalParallelism</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The execution configuration for this environment. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutionConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutionConfig</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Settings that control the checkpointing behavior. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">CheckpointConfig</span> <span class="variable">checkpointCfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckpointConfig</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;Transformation&lt;?&gt;&gt; transformations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">bufferTimeout</span> <span class="operator">=</span> ExecutionOptions.BUFFER_TIMEOUT.defaultValue().toMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="variable">isChainingEnabled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The state backend used for storing k/v state and state snapshots. */</span></span><br><span class="line">    <span class="keyword">private</span> StateBackend defaultStateBackend;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The default savepoint directory used by the job. */</span></span><br><span class="line">    <span class="keyword">private</span> Path defaultSavepointDirectory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The time characteristic used by the data streams. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TimeCharacteristic</span> <span class="variable">timeCharacteristic</span> <span class="operator">=</span> DEFAULT_TIME_CHARACTERISTIC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;Tuple2&lt;String, DistributedCache.DistributedCacheEntry&gt;&gt; cacheFile =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PipelineExecutorServiceLoader executorServiceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader userClassloader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;JobListener&gt; jobListeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Constructor and Properties</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamExecutionEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">        <span class="comment">// unfortunately, StreamExecutionEnvironment always (implicitly) had a public constructor.</span></span><br><span class="line">        <span class="comment">// This constructor is not useful because the execution environment cannot be used for</span></span><br><span class="line">        <span class="comment">// execution. We&#x27;re keeping this to appease the binary compatibiliy checks.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@link</span> StreamExecutionEnvironment&#125; that will use the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Configuration&#125; to configure the &#123;<span class="doctag">@link</span> PipelineExecutor&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamExecutionEnvironment</span><span class="params">(<span class="keyword">final</span> Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(configuration, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@link</span> StreamExecutionEnvironment&#125; that will use the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Configuration&#125; to configure the &#123;<span class="doctag">@link</span> PipelineExecutor&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In addition, this constructor allows specifying the user code &#123;<span class="doctag">@link</span> ClassLoader&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamExecutionEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> Configuration configuration, <span class="keyword">final</span> ClassLoader userClassloader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">DefaultExecutorServiceLoader</span>(), configuration, userClassloader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@link</span> StreamExecutionEnvironment&#125; that will use the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Configuration&#125; to configure the &#123;<span class="doctag">@link</span> PipelineExecutor&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In addition, this constructor allows specifying the &#123;<span class="doctag">@link</span> PipelineExecutorServiceLoader&#125;</span></span><br><span class="line"><span class="comment">     * and user code &#123;<span class="doctag">@link</span> ClassLoader&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamExecutionEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> PipelineExecutorServiceLoader executorServiceLoader,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> Configuration configuration,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> ClassLoader userClassloader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executorServiceLoader = checkNotNull(executorServiceLoader);</span><br><span class="line">        <span class="built_in">this</span>.configuration = <span class="keyword">new</span> <span class="title class_">Configuration</span>(checkNotNull(configuration));</span><br><span class="line">        <span class="built_in">this</span>.userClassloader =</span><br><span class="line">                userClassloader == <span class="literal">null</span> ? getClass().getClassLoader() : userClassloader;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the configuration of a job or an operator can be specified at the following places:</span></span><br><span class="line">        <span class="comment">//     i) at the operator level using e.g. parallelism using the</span></span><br><span class="line">        <span class="comment">// SingleOutputStreamOperator.setParallelism().</span></span><br><span class="line">        <span class="comment">//     ii) programmatically by using e.g. the env.setRestartStrategy() method</span></span><br><span class="line">        <span class="comment">//     iii) in the configuration passed here</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// if specified in multiple places, the priority order is the above.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Given this, it is safe to overwrite the execution config default values here because all</span></span><br><span class="line">        <span class="comment">// other ways assume</span></span><br><span class="line">        <span class="comment">// that the env is already instantiated so they will overwrite the value passed here.</span></span><br><span class="line">        <span class="built_in">this</span>.configure(<span class="built_in">this</span>.configuration, <span class="built_in">this</span>.userClassloader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Configuration <span class="title function_">getConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ClassLoader <span class="title function_">getUserClassloader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userClassloader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Gets the config object. */</span></span><br><span class="line">    <span class="keyword">public</span> ExecutionConfig <span class="title function_">getConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the list of cached files that were registered for distribution among the task managers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Tuple2&lt;String, DistributedCache.DistributedCacheEntry&gt;&gt; getCachedFiles() &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Gets the config JobListeners. */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;JobListener&gt; <span class="title function_">getJobListeners</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jobListeners;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the parallelism for operations executed through this environment. Setting a parallelism</span></span><br><span class="line"><span class="comment">     * of x here will cause all operators (such as map, batchReduce) to run with x parallel</span></span><br><span class="line"><span class="comment">     * instances. This method overrides the default parallelism for this environment. The &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * LocalStreamEnvironment&#125; uses by default a value equal to the number of hardware contexts (CPU</span></span><br><span class="line"><span class="comment">     * cores / threads). When executing the program via the command line client from a JAR file, the</span></span><br><span class="line"><span class="comment">     * default degree of parallelism is the one configured for that setup.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parallelism The parallelism</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setParallelism</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;</span><br><span class="line">        config.setParallelism(parallelism);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the runtime execution mode for the application (see &#123;<span class="doctag">@link</span> RuntimeExecutionMode&#125;). This</span></span><br><span class="line"><span class="comment">     * is equivalent to setting the &#123;<span class="doctag">@code</span> execution.runtime-mode&#125; in your application&#x27;s</span></span><br><span class="line"><span class="comment">     * configuration file.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;We recommend users to NOT use this method but set the &#123;<span class="doctag">@code</span> execution.runtime-mode&#125; using</span></span><br><span class="line"><span class="comment">     * the command-line when submitting the application. Keeping the application code</span></span><br><span class="line"><span class="comment">     * configuration-free allows for more flexibility as the same application will be able to be</span></span><br><span class="line"><span class="comment">     * executed in any execution mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executionMode the desired execution mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The execution environment of your application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setRuntimeMode</span><span class="params">(<span class="keyword">final</span> RuntimeExecutionMode executionMode)</span> &#123;</span><br><span class="line">        checkNotNull(executionMode);</span><br><span class="line">        configuration.set(ExecutionOptions.RUNTIME_MODE, executionMode);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the maximum degree of parallelism defined for the program. The upper limit (inclusive)</span></span><br><span class="line"><span class="comment">     * is Short.MAX_VALUE.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The maximum degree of parallelism specifies the upper limit for dynamic scaling. It also</span></span><br><span class="line"><span class="comment">     * defines the number of key groups used for partitioned state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxParallelism Maximum degree of parallelism to be used for the program., with &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     *     0 &lt; maxParallelism &lt;= 2^15 - 1&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setMaxParallelism</span><span class="params">(<span class="type">int</span> maxParallelism)</span> &#123;</span><br><span class="line">        Preconditions.checkArgument(</span><br><span class="line">                maxParallelism &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; maxParallelism &lt;= KeyGroupRangeAssignment.UPPER_BOUND_MAX_PARALLELISM,</span><br><span class="line">                <span class="string">&quot;maxParallelism is out of bounds 0 &lt; maxParallelism &lt;= &quot;</span></span><br><span class="line">                        + KeyGroupRangeAssignment.UPPER_BOUND_MAX_PARALLELISM</span><br><span class="line">                        + <span class="string">&quot;. Found: &quot;</span></span><br><span class="line">                        + maxParallelism);</span><br><span class="line"></span><br><span class="line">        config.setMaxParallelism(maxParallelism);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the parallelism with which operation are executed by default. Operations can</span></span><br><span class="line"><span class="comment">     * individually override this value to use a specific parallelism.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The parallelism used by operations, unless they override that value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getParallelism</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config.getParallelism();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the maximum degree of parallelism defined for the program.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The maximum degree of parallelism specifies the upper limit for dynamic scaling. It also</span></span><br><span class="line"><span class="comment">     * defines the number of key groups used for partitioned state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Maximum degree of parallelism</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxParallelism</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config.getMaxParallelism();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the maximum time frequency (milliseconds) for the flushing of the output buffers. By</span></span><br><span class="line"><span class="comment">     * default the output buffers flush frequently to provide low latency and to aid smooth</span></span><br><span class="line"><span class="comment">     * developer experience. Setting the parameter can result in three logical modes:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;A positive integer triggers flushing periodically by that integer</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;0 triggers flushing after every record thus minimizing latency</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;-1 triggers flushing only when the output buffer is full thus maximizing throughput</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutMillis The maximum time between two output flushes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setBufferTimeout</span><span class="params">(<span class="type">long</span> timeoutMillis)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeoutMillis &lt; ExecutionOptions.DISABLED_NETWORK_BUFFER_TIMEOUT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Timeout of buffer must be non-negative or -1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.bufferTimeout = timeoutMillis;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the maximum time frequency (milliseconds) for the flushing of the output buffers. For</span></span><br><span class="line"><span class="comment">     * clarification on the extremal values see &#123;<span class="doctag">@link</span> #setBufferTimeout(long)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The timeout of the buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getBufferTimeout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bufferTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Disables operator chaining for streaming operators. Operator chaining allows non-shuffle</span></span><br><span class="line"><span class="comment">     * operations to be co-located in the same thread fully avoiding serialization and</span></span><br><span class="line"><span class="comment">     * de-serialization.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> StreamExecutionEnvironment with chaining disabled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">disableOperatorChaining</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isChainingEnabled = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns whether operator chaining is enabled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if chaining is enabled, false otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChainingEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isChainingEnabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Checkpointing Settings</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the checkpoint config, which defines values like checkpoint interval, delay between</span></span><br><span class="line"><span class="comment">     * checkpoints, etc.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The checkpoint config.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> CheckpointConfig <span class="title function_">getCheckpointConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkpointCfg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enables checkpointing for the streaming job. The distributed state of the streaming dataflow</span></span><br><span class="line"><span class="comment">     * will be periodically snapshotted. In case of a failure, the streaming dataflow will be</span></span><br><span class="line"><span class="comment">     * restarted from the latest completed checkpoint. This method selects &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * CheckpointingMode#EXACTLY_ONCE&#125; guarantees.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The job draws checkpoints periodically, in the given interval. The state will be stored in</span></span><br><span class="line"><span class="comment">     * the configured state backend.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;<span class="doctag">NOTE:</span> Checkpointing iterative streaming dataflows in not properly supported at the moment.</span></span><br><span class="line"><span class="comment">     * For that reason, iterative jobs will not be started if used with enabled checkpointing. To</span></span><br><span class="line"><span class="comment">     * override this mechanism, use the &#123;<span class="doctag">@link</span> #enableCheckpointing(long, CheckpointingMode,</span></span><br><span class="line"><span class="comment">     * boolean)&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval Time interval between state checkpoints in milliseconds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">enableCheckpointing</span><span class="params">(<span class="type">long</span> interval)</span> &#123;</span><br><span class="line">        checkpointCfg.setCheckpointInterval(interval);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enables checkpointing for the streaming job. The distributed state of the streaming dataflow</span></span><br><span class="line"><span class="comment">     * will be periodically snapshotted. In case of a failure, the streaming dataflow will be</span></span><br><span class="line"><span class="comment">     * restarted from the latest completed checkpoint.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The job draws checkpoints periodically, in the given interval. The system uses the given</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> CheckpointingMode&#125; for the checkpointing (&quot;exactly once&quot; vs &quot;at least once&quot;). The</span></span><br><span class="line"><span class="comment">     * state will be stored in the configured state backend.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;<span class="doctag">NOTE:</span> Checkpointing iterative streaming dataflows in not properly supported at the moment.</span></span><br><span class="line"><span class="comment">     * For that reason, iterative jobs will not be started if used with enabled checkpointing. To</span></span><br><span class="line"><span class="comment">     * override this mechanism, use the &#123;<span class="doctag">@link</span> #enableCheckpointing(long, CheckpointingMode,</span></span><br><span class="line"><span class="comment">     * boolean)&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval Time interval between state checkpoints in milliseconds.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode The checkpointing mode, selecting between &quot;exactly once&quot; and &quot;at least once&quot;</span></span><br><span class="line"><span class="comment">     *     guaranteed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">enableCheckpointing</span><span class="params">(<span class="type">long</span> interval, CheckpointingMode mode)</span> &#123;</span><br><span class="line">        checkpointCfg.setCheckpointingMode(mode);</span><br><span class="line">        checkpointCfg.setCheckpointInterval(interval);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enables checkpointing for the streaming job. The distributed state of the streaming dataflow</span></span><br><span class="line"><span class="comment">     * will be periodically snapshotted. In case of a failure, the streaming dataflow will be</span></span><br><span class="line"><span class="comment">     * restarted from the latest completed checkpoint.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The job draws checkpoints periodically, in the given interval. The state will be stored in</span></span><br><span class="line"><span class="comment">     * the configured state backend.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;<span class="doctag">NOTE:</span> Checkpointing iterative streaming dataflows in not properly supported at the moment.</span></span><br><span class="line"><span class="comment">     * If the &quot;force&quot; parameter is set to true, the system will execute the job nonetheless.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval Time interval between state checkpoints in millis.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode The checkpointing mode, selecting between &quot;exactly once&quot; and &quot;at least once&quot;</span></span><br><span class="line"><span class="comment">     *     guaranteed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> force If true checkpointing will be enabled for iterative jobs as well.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #enableCheckpointing(long, CheckpointingMode)&#125; instead. Forcing</span></span><br><span class="line"><span class="comment">     *     checkpoints will be removed in the future.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">enableCheckpointing</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="type">long</span> interval, CheckpointingMode mode, <span class="type">boolean</span> force)</span> &#123;</span><br><span class="line">        checkpointCfg.setCheckpointingMode(mode);</span><br><span class="line">        checkpointCfg.setCheckpointInterval(interval);</span><br><span class="line">        checkpointCfg.setForceCheckpointing(force);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enables checkpointing for the streaming job. The distributed state of the streaming dataflow</span></span><br><span class="line"><span class="comment">     * will be periodically snapshotted. In case of a failure, the streaming dataflow will be</span></span><br><span class="line"><span class="comment">     * restarted from the latest completed checkpoint. This method selects &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * CheckpointingMode#EXACTLY_ONCE&#125; guarantees.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The job draws checkpoints periodically, in the default interval. The state will be stored</span></span><br><span class="line"><span class="comment">     * in the configured state backend.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;<span class="doctag">NOTE:</span> Checkpointing iterative streaming dataflows in not properly supported at the moment.</span></span><br><span class="line"><span class="comment">     * For that reason, iterative jobs will not be started if used with enabled checkpointing. To</span></span><br><span class="line"><span class="comment">     * override this mechanism, use the &#123;<span class="doctag">@link</span> #enableCheckpointing(long, CheckpointingMode,</span></span><br><span class="line"><span class="comment">     * boolean)&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #enableCheckpointing(long)&#125; instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">enableCheckpointing</span><span class="params">()</span> &#123;</span><br><span class="line">        checkpointCfg.setCheckpointInterval(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the checkpointing interval or -1 if checkpointing is disabled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Shorthand for &#123;<span class="doctag">@code</span> getCheckpointConfig().getCheckpointInterval()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The checkpointing interval or -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCheckpointInterval</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkpointCfg.getCheckpointInterval();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns whether checkpointing is force-enabled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Forcing checkpoints will be removed in future version.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isForceCheckpointing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkpointCfg.isForceCheckpointing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether unaligned checkpoints are enabled. */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUnalignedCheckpointsEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkpointCfg.isUnalignedCheckpointsEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether unaligned checkpoints are force-enabled. */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isForceUnalignedCheckpoints</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkpointCfg.isForceUnalignedCheckpoints();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the checkpointing mode (exactly-once vs. at-least-once).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Shorthand for &#123;<span class="doctag">@code</span> getCheckpointConfig().getCheckpointingMode()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The checkpoint mode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> CheckpointingMode <span class="title function_">getCheckpointingMode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkpointCfg.getCheckpointingMode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the state backend that describes how to store operator. It defines the data structures</span></span><br><span class="line"><span class="comment">     * that hold state during execution (for example hash tables, RocksDB, or other data stores).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;State managed by the state backend includes both keyed state that is accessible on &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.streaming.api.datastream.KeyedStream keyed streams&#125;, as well as state</span></span><br><span class="line"><span class="comment">     * maintained directly by the user code that implements &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.streaming.api.checkpoint.CheckpointedFunction CheckpointedFunction&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The &#123;<span class="doctag">@link</span> org.apache.flink.runtime.state.hashmap.HashMapStateBackend&#125; maintains state in</span></span><br><span class="line"><span class="comment">     * heap memory, as objects. It is lightweight without extra dependencies, but is limited to JVM</span></span><br><span class="line"><span class="comment">     * heap memory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In contrast, the &#123;<span class="doctag">@code</span> EmbeddedRocksDBStateBackend&#125; stores its state in an embedded</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> RocksDB&#125; instance. This state backend can store very large state that exceeds memory</span></span><br><span class="line"><span class="comment">     * and spills to local disk. All key/value state (including windows) is stored in the key/value</span></span><br><span class="line"><span class="comment">     * index of RocksDB.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In both cases, fault tolerance is managed via the jobs &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.runtime.state.CheckpointStorage&#125; which configures how and where state</span></span><br><span class="line"><span class="comment">     * backends persist during a checkpoint.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> This StreamExecutionEnvironment itself, to allow chaining of function calls.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getStateBackend()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> CheckpointConfig#setCheckpointStorage( org.apache.flink.runtime.state.CheckpointStorage)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setStateBackend</span><span class="params">(StateBackend backend)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.defaultStateBackend = Preconditions.checkNotNull(backend);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the state backend that defines how to store and checkpoint state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setStateBackend(StateBackend)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StateBackend <span class="title function_">getStateBackend</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultStateBackend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the default savepoint directory, where savepoints will be written to if no is explicitly</span></span><br><span class="line"><span class="comment">     * provided when triggered.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> This StreamExecutionEnvironment itself, to allow chaining of function calls.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getDefaultSavepointDirectory()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setDefaultSavepointDirectory</span><span class="params">(String savepointDirectory)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(savepointDirectory);</span><br><span class="line">        <span class="keyword">return</span> setDefaultSavepointDirectory(<span class="keyword">new</span> <span class="title class_">Path</span>(savepointDirectory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the default savepoint directory, where savepoints will be written to if no is explicitly</span></span><br><span class="line"><span class="comment">     * provided when triggered.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> This StreamExecutionEnvironment itself, to allow chaining of function calls.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getDefaultSavepointDirectory()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setDefaultSavepointDirectory</span><span class="params">(URI savepointDirectory)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(savepointDirectory);</span><br><span class="line">        <span class="keyword">return</span> setDefaultSavepointDirectory(<span class="keyword">new</span> <span class="title class_">Path</span>(savepointDirectory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the default savepoint directory, where savepoints will be written to if no is explicitly</span></span><br><span class="line"><span class="comment">     * provided when triggered.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> This StreamExecutionEnvironment itself, to allow chaining of function calls.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getDefaultSavepointDirectory()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> StreamExecutionEnvironment <span class="title function_">setDefaultSavepointDirectory</span><span class="params">(Path savepointDirectory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.defaultSavepointDirectory = Preconditions.checkNotNull(savepointDirectory);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the default savepoint directory for this Job.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setDefaultSavepointDirectory(Path)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> Path <span class="title function_">getDefaultSavepointDirectory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultSavepointDirectory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the restart strategy configuration. The configuration specifies which restart strategy</span></span><br><span class="line"><span class="comment">     * will be used for the execution graph in case of a restart.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> restartStrategyConfiguration Restart strategy configuration to be set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRestartStrategy</span><span class="params">(</span></span><br><span class="line"><span class="params">            RestartStrategies.RestartStrategyConfiguration restartStrategyConfiguration)</span> &#123;</span><br><span class="line">        config.setRestartStrategy(restartStrategyConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the specified restart strategy configuration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The restart strategy configuration to be used</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> RestartStrategies.RestartStrategyConfiguration <span class="title function_">getRestartStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config.getRestartStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the number of times that failed tasks are re-executed. A value of zero effectively</span></span><br><span class="line"><span class="comment">     * disables fault tolerance. A value of &#123;<span class="doctag">@code</span> -1&#125; indicates that the system default value (as</span></span><br><span class="line"><span class="comment">     * defined in the configuration) should be used.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numberOfExecutionRetries The number of times the system will try to re-execute failed</span></span><br><span class="line"><span class="comment">     *     tasks.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> This method will be replaced by &#123;<span class="doctag">@link</span> #setRestartStrategy&#125;. The &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     RestartStrategies#fixedDelayRestart(int, Time)&#125; contains the number of execution retries.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumberOfExecutionRetries</span><span class="params">(<span class="type">int</span> numberOfExecutionRetries)</span> &#123;</span><br><span class="line">        config.setNumberOfExecutionRetries(numberOfExecutionRetries);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the number of times the system will try to re-execute failed tasks. A value of &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * -1&#125; indicates that the system default value (as defined in the configuration) should be used.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The number of times the system will try to re-execute failed tasks.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> This method will be replaced by &#123;<span class="doctag">@link</span> #getRestartStrategy&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumberOfExecutionRetries</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config.getNumberOfExecutionRetries();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Registry for types and serializers</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a new Kryo default serializer to the Runtime.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that the serializer instance must be serializable (as defined by</span></span><br><span class="line"><span class="comment">     * java.io.Serializable), because it may be distributed to the worker nodes by java</span></span><br><span class="line"><span class="comment">     * serialization.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the types serialized with the given serializer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serializer The serializer to use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Serializer</span>&lt;?&gt; &amp; Serializable&gt; <span class="keyword">void</span> <span class="title function_">addDefaultKryoSerializer</span><span class="params">(</span></span><br><span class="line"><span class="params">            Class&lt;?&gt; type, T serializer)</span> &#123;</span><br><span class="line">        config.addDefaultKryoSerializer(type, serializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a new Kryo default serializer to the Runtime.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the types serialized with the given serializer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serializerClass The class of the serializer to use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDefaultKryoSerializer</span><span class="params">(</span></span><br><span class="line"><span class="params">            Class&lt;?&gt; type, Class&lt;? extends Serializer&lt;?&gt;&gt; serializerClass)</span> &#123;</span><br><span class="line">        config.addDefaultKryoSerializer(type, serializerClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers the given type with a Kryo Serializer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that the serializer instance must be serializable (as defined by</span></span><br><span class="line"><span class="comment">     * java.io.Serializable), because it may be distributed to the worker nodes by java</span></span><br><span class="line"><span class="comment">     * serialization.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the types serialized with the given serializer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serializer The serializer to use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Serializer</span>&lt;?&gt; &amp; Serializable&gt; <span class="keyword">void</span> <span class="title function_">registerTypeWithKryoSerializer</span><span class="params">(</span></span><br><span class="line"><span class="params">            Class&lt;?&gt; type, T serializer)</span> &#123;</span><br><span class="line">        config.registerTypeWithKryoSerializer(type, serializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers the given Serializer via its class as a serializer for the given type at the</span></span><br><span class="line"><span class="comment">     * KryoSerializer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the types serialized with the given serializer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serializerClass The class of the serializer to use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerTypeWithKryoSerializer</span><span class="params">(</span></span><br><span class="line"><span class="params">            Class&lt;?&gt; type, Class&lt;? extends Serializer&gt; serializerClass)</span> &#123;</span><br><span class="line">        config.registerTypeWithKryoSerializer(type, serializerClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers the given type with the serialization stack. If the type is eventually serialized</span></span><br><span class="line"><span class="comment">     * as a POJO, then the type is registered with the POJO serializer. If the type ends up being</span></span><br><span class="line"><span class="comment">     * serialized with Kryo, then it will be registered at Kryo to make sure that only tags are</span></span><br><span class="line"><span class="comment">     * written.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the type to register.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerType</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Cannot register null type class.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;?&gt; typeInfo = TypeExtractor.createTypeInfo(type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (typeInfo <span class="keyword">instanceof</span> PojoTypeInfo) &#123;</span><br><span class="line">            config.registerPojoType(type);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            config.registerKryoType(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Time characteristic</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the time characteristic for all streams create from this environment, e.g., processing</span></span><br><span class="line"><span class="comment">     * time, event time, or ingestion time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If you set the characteristic to IngestionTime of EventTime this will set a default</span></span><br><span class="line"><span class="comment">     * watermark update interval of 200 ms. If this is not applicable for your application you</span></span><br><span class="line"><span class="comment">     * should change it using &#123;<span class="doctag">@link</span> ExecutionConfig#setAutoWatermarkInterval(long)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> characteristic The time characteristic.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> In Flink 1.12 the default stream time characteristic has been changed to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     TimeCharacteristic#EventTime&#125;, thus you don&#x27;t need to call this method for enabling</span></span><br><span class="line"><span class="comment">     *     event-time support anymore. Explicitly using processing-time windows and timers works in</span></span><br><span class="line"><span class="comment">     *     event-time mode. If you need to disable watermarks, please use &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     ExecutionConfig#setAutoWatermarkInterval(long)&#125;. If you are using &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     TimeCharacteristic#IngestionTime&#125;, please manually set an appropriate &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     WatermarkStrategy&#125;. If you are using generic &quot;time window&quot; operations (for example &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     org.apache.flink.streaming.api.datastream.KeyedStream#timeWindow(org.apache.flink.streaming.api.windowing.time.Time)&#125;</span></span><br><span class="line"><span class="comment">     *     that change behaviour based on the time characteristic, please use equivalent operations</span></span><br><span class="line"><span class="comment">     *     that explicitly specify processing time or event time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStreamTimeCharacteristic</span><span class="params">(TimeCharacteristic characteristic)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.timeCharacteristic = Preconditions.checkNotNull(characteristic);</span><br><span class="line">        <span class="keyword">if</span> (characteristic == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">            getConfig().setAutoWatermarkInterval(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getConfig().setAutoWatermarkInterval(<span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the time characteristic.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> See &#123;<span class="doctag">@link</span> #setStreamTimeCharacteristic(TimeCharacteristic)&#125; for deprecation</span></span><br><span class="line"><span class="comment">     *     notice.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> TimeCharacteristic <span class="title function_">getStreamTimeCharacteristic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> timeCharacteristic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets all relevant options contained in the &#123;<span class="doctag">@link</span> ReadableConfig&#125; such as e.g. &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * StreamPipelineOptions#TIME_CHARACTERISTIC&#125;. It will reconfigure &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * StreamExecutionEnvironment&#125;, &#123;<span class="doctag">@link</span> ExecutionConfig&#125; and &#123;<span class="doctag">@link</span> CheckpointConfig&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;It will change the value of a setting only if a corresponding option was set in the &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * configuration&#125;. If a key is not present, the current value of a field will remain untouched.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration a configuration to read the values from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader a class loader to use when loading classes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ReadableConfig configuration, ClassLoader classLoader)</span> &#123;</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(StreamPipelineOptions.TIME_CHARACTERISTIC)</span><br><span class="line">                .ifPresent(<span class="built_in">this</span>::setStreamTimeCharacteristic);</span><br><span class="line">        Optional.ofNullable(loadStateBackend(configuration, classLoader))</span><br><span class="line">                .ifPresent(<span class="built_in">this</span>::setStateBackend);</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(PipelineOptions.OPERATOR_CHAINING)</span><br><span class="line">                .ifPresent(c -&gt; <span class="built_in">this</span>.isChainingEnabled = c);</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(ExecutionOptions.BUFFER_TIMEOUT)</span><br><span class="line">                .ifPresent(t -&gt; <span class="built_in">this</span>.setBufferTimeout(t.toMillis()));</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(DeploymentOptions.JOB_LISTENERS)</span><br><span class="line">                .ifPresent(listeners -&gt; registerCustomListeners(classLoader, listeners));</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(PipelineOptions.CACHED_FILES)</span><br><span class="line">                .ifPresent(</span><br><span class="line">                        f -&gt; &#123;</span><br><span class="line">                            <span class="built_in">this</span>.cacheFile.clear();</span><br><span class="line">                            <span class="built_in">this</span>.cacheFile.addAll(DistributedCache.parseCachedFilesFromString(f));</span><br><span class="line">                        &#125;);</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(ExecutionOptions.RUNTIME_MODE)</span><br><span class="line">                .ifPresent(</span><br><span class="line">                        runtimeMode -&gt;</span><br><span class="line">                                <span class="built_in">this</span>.configuration.set(ExecutionOptions.RUNTIME_MODE, runtimeMode));</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(ExecutionOptions.SORT_INPUTS)</span><br><span class="line">                .ifPresent(</span><br><span class="line">                        sortInputs -&gt;</span><br><span class="line">                                <span class="built_in">this</span>.getConfiguration()</span><br><span class="line">                                        .set(ExecutionOptions.SORT_INPUTS, sortInputs));</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(ExecutionOptions.USE_BATCH_STATE_BACKEND)</span><br><span class="line">                .ifPresent(</span><br><span class="line">                        sortInputs -&gt;</span><br><span class="line">                                <span class="built_in">this</span>.getConfiguration()</span><br><span class="line">                                        .set(ExecutionOptions.USE_BATCH_STATE_BACKEND, sortInputs));</span><br><span class="line">        configuration</span><br><span class="line">                .getOptional(PipelineOptions.NAME)</span><br><span class="line">                .ifPresent(jobName -&gt; <span class="built_in">this</span>.getConfiguration().set(PipelineOptions.NAME, jobName));</span><br><span class="line">        config.configure(configuration, classLoader);</span><br><span class="line">        checkpointCfg.configure(configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerCustomListeners</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> ClassLoader classLoader, <span class="keyword">final</span> List&lt;String&gt; listeners)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String listener : listeners) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">JobListener</span> <span class="variable">jobListener</span> <span class="operator">=</span></span><br><span class="line">                        InstantiationUtil.instantiate(listener, JobListener.class, classLoader);</span><br><span class="line">                jobListeners.add(jobListener);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FlinkException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">WrappingRuntimeException</span>(<span class="string">&quot;Could not load JobListener : &quot;</span> + listener, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StateBackend <span class="title function_">loadStateBackend</span><span class="params">(ReadableConfig configuration, ClassLoader classLoader)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> StateBackendLoader.loadStateBackendFromConfig(configuration, classLoader, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DynamicCodeLoadingException | IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">WrappingRuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Data stream creations</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains a sequence of numbers. This is a parallel source, if</span></span><br><span class="line"><span class="comment">     * you manually set the parallelism to &#123;<span class="doctag">@code</span> 1&#125; (using &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator#setParallelism(int)&#125;)</span></span><br><span class="line"><span class="comment">     * the generated sequence of elements is in order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from The number to start at (inclusive)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to The number to stop at (inclusive)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream, containing all number in the [from, to] interval</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #fromSequence(long, long)&#125; instead to create a new data stream that</span></span><br><span class="line"><span class="comment">     *     contains &#123;<span class="doctag">@link</span> org.apache.flink.api.connector.source.lib.NumberSequenceSource&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;Long&gt; <span class="title function_">generateSequence</span><span class="params">(<span class="type">long</span> from, <span class="type">long</span> to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from &gt; to) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;Start of sequence must not be greater than the end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addSource(<span class="keyword">new</span> <span class="title class_">StatefulSequenceSource</span>(from, to), <span class="string">&quot;Sequence Source (Deprecated)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains a sequence of numbers (longs) and is useful for</span></span><br><span class="line"><span class="comment">     * testing and for cases that just need a stream of N events of any kind.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The generated source splits the sequence into as many parallel sub-sequences as there are</span></span><br><span class="line"><span class="comment">     * parallel source readers. Each sub-sequence will be produced in order. If the parallelism is</span></span><br><span class="line"><span class="comment">     * limited to one, the source will produce one sequence in order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This source is always bounded. For very long sequences (for example over the entire domain</span></span><br><span class="line"><span class="comment">     * of long integer values), you may consider executing the application in a streaming manner</span></span><br><span class="line"><span class="comment">     * because of the end bound that is pretty far away.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Use &#123;<span class="doctag">@link</span> #fromSource(Source, WatermarkStrategy, String)&#125; together with &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * NumberSequenceSource&#125; if you required more control over the created sources. For example, if</span></span><br><span class="line"><span class="comment">     * you want to set a &#123;<span class="doctag">@link</span> WatermarkStrategy&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from The number to start at (inclusive)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to The number to stop at (inclusive)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;Long&gt; <span class="title function_">fromSequence</span><span class="params">(<span class="type">long</span> from, <span class="type">long</span> to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from &gt; to) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;Start of sequence must not be greater than the end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fromSource(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NumberSequenceSource</span>(from, to),</span><br><span class="line">                WatermarkStrategy.noWatermarks(),</span><br><span class="line">                <span class="string">&quot;Sequence Source&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains the given elements. The elements must all be of the</span></span><br><span class="line"><span class="comment">     * same type, for example, all of the &#123;<span class="doctag">@link</span> String&#125; or &#123;<span class="doctag">@link</span> Integer&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The framework will try and determine the exact type from the elements. In case of generic</span></span><br><span class="line"><span class="comment">     * elements, it may be necessary to manually supply the type information via &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #fromCollection(java.util.Collection, org.apache.flink.api.common.typeinfo.TypeInformation)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this operation will result in a non-parallel data stream source, i.e. a data</span></span><br><span class="line"><span class="comment">     * stream source with a degree of parallelism one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data The array of elements to create the data stream from.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream representing the given array of elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromElements</span><span class="params">(OUT... data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;fromElements needs at least one element as argument&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;OUT&gt; typeInfo;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            typeInfo = TypeExtractor.getForObject(data[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Could not create TypeInformation for type &quot;</span></span><br><span class="line">                            + data[<span class="number">0</span>].getClass().getName()</span><br><span class="line">                            + <span class="string">&quot;; please specify the TypeInformation manually via &quot;</span></span><br><span class="line">                            + <span class="string">&quot;StreamExecutionEnvironment#fromElements(Collection, TypeInformation)&quot;</span>,</span><br><span class="line">                    e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fromCollection(Arrays.asList(data), typeInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data set that contains the given elements. The framework will determine the</span></span><br><span class="line"><span class="comment">     * type according to the based type user supplied. The elements should be the same or be the</span></span><br><span class="line"><span class="comment">     * subclass to the based type. The sequence of elements must not be empty. Note that this</span></span><br><span class="line"><span class="comment">     * operation will result in a non-parallel data stream source, i.e. a data stream source with a</span></span><br><span class="line"><span class="comment">     * degree of parallelism one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The based class type in the collection.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data The array of elements to create the data stream from.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream representing the given array of elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromElements</span><span class="params">(Class&lt;OUT&gt; type, OUT... data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;fromElements needs at least one element as argument&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;OUT&gt; typeInfo;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            typeInfo = TypeExtractor.getForClass(type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Could not create TypeInformation for type &quot;</span></span><br><span class="line">                            + type.getName()</span><br><span class="line">                            + <span class="string">&quot;; please specify the TypeInformation manually via &quot;</span></span><br><span class="line">                            + <span class="string">&quot;StreamExecutionEnvironment#fromElements(Collection, TypeInformation)&quot;</span>,</span><br><span class="line">                    e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fromCollection(Arrays.asList(data), typeInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a data stream from the given non-empty collection. The type of the data stream is</span></span><br><span class="line"><span class="comment">     * that of the elements in the collection.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The framework will try and determine the exact type from the collection elements. In case</span></span><br><span class="line"><span class="comment">     * of generic elements, it may be necessary to manually supply the type information via &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #fromCollection(java.util.Collection, org.apache.flink.api.common.typeinfo.TypeInformation)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this operation will result in a non-parallel data stream source, i.e. a data</span></span><br><span class="line"><span class="comment">     * stream source with parallelism one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data The collection of elements to create the data stream from.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The generic type of the returned data stream.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream representing the given collection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromCollection</span><span class="params">(Collection&lt;OUT&gt; data)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(data, <span class="string">&quot;Collection must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (data.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Collection must not be empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">OUT</span> <span class="variable">first</span> <span class="operator">=</span> data.iterator().next();</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Collection must not contain null elements&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;OUT&gt; typeInfo;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            typeInfo = TypeExtractor.getForObject(first);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Could not create TypeInformation for type &quot;</span></span><br><span class="line">                            + first.getClass()</span><br><span class="line">                            + <span class="string">&quot;; please specify the TypeInformation manually via &quot;</span></span><br><span class="line">                            + <span class="string">&quot;StreamExecutionEnvironment#fromElements(Collection, TypeInformation)&quot;</span>,</span><br><span class="line">                    e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fromCollection(data, typeInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a data stream from the given non-empty collection.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this operation will result in a non-parallel data stream source, i.e., a data</span></span><br><span class="line"><span class="comment">     * stream source with parallelism one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data The collection of elements to create the data stream from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo The TypeInformation for the produced data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream representing the given collection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromCollection</span><span class="params">(</span></span><br><span class="line"><span class="params">            Collection&lt;OUT&gt; data, TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(data, <span class="string">&quot;Collection must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// must not have null elements and mixed elements</span></span><br><span class="line">        FromElementsFunction.checkCollection(data, typeInfo.getTypeClass());</span><br><span class="line"></span><br><span class="line">        SourceFunction&lt;OUT&gt; function = <span class="keyword">new</span> <span class="title class_">FromElementsFunction</span>&lt;&gt;(data);</span><br><span class="line">        <span class="keyword">return</span> addSource(function, <span class="string">&quot;Collection Source&quot;</span>, typeInfo, Boundedness.BOUNDED)</span><br><span class="line">                .setParallelism(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a data stream from the given iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Because the iterator will remain unmodified until the actual execution happens, the type</span></span><br><span class="line"><span class="comment">     * of data returned by the iterator must be given explicitly in the form of the type class (this</span></span><br><span class="line"><span class="comment">     * is due to the fact that the Java compiler erases the generic type information).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this operation will result in a non-parallel data stream source, i.e., a data</span></span><br><span class="line"><span class="comment">     * stream source with a parallelism of one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data The iterator of elements to create the data stream from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the data produced by the iterator. Must not be a generic class.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream representing the elements in the iterator</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #fromCollection(java.util.Iterator,</span></span><br><span class="line"><span class="comment">     *     org.apache.flink.api.common.typeinfo.TypeInformation)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromCollection</span><span class="params">(Iterator&lt;OUT&gt; data, Class&lt;OUT&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fromCollection(data, TypeExtractor.getForClass(type));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a data stream from the given iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Because the iterator will remain unmodified until the actual execution happens, the type</span></span><br><span class="line"><span class="comment">     * of data returned by the iterator must be given explicitly in the form of the type</span></span><br><span class="line"><span class="comment">     * information. This method is useful for cases where the type is generic. In that case, the</span></span><br><span class="line"><span class="comment">     * type class (as given in &#123;<span class="doctag">@link</span> #fromCollection(java.util.Iterator, Class)&#125; does not supply</span></span><br><span class="line"><span class="comment">     * all type information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this operation will result in a non-parallel data stream source, i.e., a data</span></span><br><span class="line"><span class="comment">     * stream source with parallelism one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data The iterator of elements to create the data stream from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo The TypeInformation for the produced data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream representing the elements in the iterator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromCollection</span><span class="params">(</span></span><br><span class="line"><span class="params">            Iterator&lt;OUT&gt; data, TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(data, <span class="string">&quot;The iterator must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SourceFunction&lt;OUT&gt; function = <span class="keyword">new</span> <span class="title class_">FromIteratorFunction</span>&lt;&gt;(data);</span><br><span class="line">        <span class="keyword">return</span> addSource(function, <span class="string">&quot;Collection Source&quot;</span>, typeInfo, Boundedness.BOUNDED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains elements in the iterator. The iterator is splittable,</span></span><br><span class="line"><span class="comment">     * allowing the framework to create a parallel data stream source that returns the elements in</span></span><br><span class="line"><span class="comment">     * the iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Because the iterator will remain unmodified until the actual execution happens, the type</span></span><br><span class="line"><span class="comment">     * of data returned by the iterator must be given explicitly in the form of the type class (this</span></span><br><span class="line"><span class="comment">     * is due to the fact that the Java compiler erases the generic type information).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iterator The iterator that produces the elements of the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type The class of the data produced by the iterator. Must not be a generic class.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream representing the elements in the iterator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromParallelCollection</span><span class="params">(</span></span><br><span class="line"><span class="params">            SplittableIterator&lt;OUT&gt; iterator, Class&lt;OUT&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fromParallelCollection(iterator, TypeExtractor.getForClass(type));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains elements in the iterator. The iterator is splittable,</span></span><br><span class="line"><span class="comment">     * allowing the framework to create a parallel data stream source that returns the elements in</span></span><br><span class="line"><span class="comment">     * the iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Because the iterator will remain unmodified until the actual execution happens, the type</span></span><br><span class="line"><span class="comment">     * of data returned by the iterator must be given explicitly in the form of the type</span></span><br><span class="line"><span class="comment">     * information. This method is useful for cases where the type is generic. In that case, the</span></span><br><span class="line"><span class="comment">     * type class (as given in &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #fromParallelCollection(org.apache.flink.util.SplittableIterator, Class)&#125; does not supply all</span></span><br><span class="line"><span class="comment">     * type information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iterator The iterator that produces the elements of the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo The TypeInformation for the produced data stream.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream representing the elements in the iterator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromParallelCollection</span><span class="params">(</span></span><br><span class="line"><span class="params">            SplittableIterator&lt;OUT&gt; iterator, TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fromParallelCollection(iterator, typeInfo, <span class="string">&quot;Parallel Collection Source&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private helper for passing different names</span></span><br><span class="line">    <span class="keyword">private</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromParallelCollection</span><span class="params">(</span></span><br><span class="line"><span class="params">            SplittableIterator&lt;OUT&gt; iterator, TypeInformation&lt;OUT&gt; typeInfo, String operatorName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addSource(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FromSplittableIteratorFunction</span>&lt;&gt;(iterator),</span><br><span class="line">                operatorName,</span><br><span class="line">                typeInfo,</span><br><span class="line">                Boundedness.BOUNDED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the given file line-by-line and creates a data stream that contains a string with the</span></span><br><span class="line"><span class="comment">     * contents of each such line. The file will be read with the UTF-8 character set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; The source monitors the path, creates the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards them to</span></span><br><span class="line"><span class="comment">     * the downstream readers to read the actual data, and exits, without waiting for the readers to</span></span><br><span class="line"><span class="comment">     * finish reading. This implies that no more checkpoint barriers are going to be forwarded after</span></span><br><span class="line"><span class="comment">     * the source exits, thus having no checkpoints after that point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path&quot;).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data read from the given file as text lines</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">readTextFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> readTextFile(filePath, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the given file line-by-line and creates a data stream that contains a string with the</span></span><br><span class="line"><span class="comment">     * contents of each such line. The &#123;<span class="doctag">@link</span> java.nio.charset.Charset&#125; with the given name will be</span></span><br><span class="line"><span class="comment">     * used to read the files.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; The source monitors the path, creates the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards them to</span></span><br><span class="line"><span class="comment">     * the downstream readers to read the actual data, and exits, without waiting for the readers to</span></span><br><span class="line"><span class="comment">     * finish reading. This implies that no more checkpoint barriers are going to be forwarded after</span></span><br><span class="line"><span class="comment">     * the source exits, thus having no checkpoints after that point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charsetName The name of the character set used to read the file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data read from the given file as text lines</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">readTextFile</span><span class="params">(String filePath, String charsetName)</span> &#123;</span><br><span class="line">        Preconditions.checkArgument(</span><br><span class="line">                !StringUtils.isNullOrWhitespaceOnly(filePath),</span><br><span class="line">                <span class="string">&quot;The file path must not be null or blank.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TextInputFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextInputFormat</span>(<span class="keyword">new</span> <span class="title class_">Path</span>(filePath));</span><br><span class="line">        format.setFilesFilter(FilePathFilter.createDefaultFilter());</span><br><span class="line">        TypeInformation&lt;String&gt; typeInfo = BasicTypeInfo.STRING_TYPE_INFO;</span><br><span class="line">        format.setCharsetName(charsetName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> readFile(format, filePath, FileProcessingMode.PROCESS_ONCE, -<span class="number">1</span>, typeInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the contents of the user-specified &#123;<span class="doctag">@code</span> filePath&#125; based on the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileInputFormat&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Since all data streams need specific information about their types, this method needs to</span></span><br><span class="line"><span class="comment">     * determine the type of the data produced by the input format. It will attempt to determine the</span></span><br><span class="line"><span class="comment">     * data type by reflection, unless the input format implements the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.java.typeutils.ResultTypeQueryable&#125; interface. In the latter case, this</span></span><br><span class="line"><span class="comment">     * method will invoke the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.java.typeutils.ResultTypeQueryable#getProducedType()&#125; method to</span></span><br><span class="line"><span class="comment">     * determine data type produced by the input format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; The source monitors the path, creates the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards them to</span></span><br><span class="line"><span class="comment">     * the downstream readers to read the actual data, and exits, without waiting for the readers to</span></span><br><span class="line"><span class="comment">     * finish reading. This implies that no more checkpoint barriers are going to be forwarded after</span></span><br><span class="line"><span class="comment">     * the source exits, thus having no checkpoints after that point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFormat The input format used to create the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data read from the given file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">readFile</span><span class="params">(FileInputFormat&lt;OUT&gt; inputFormat, String filePath)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> readFile(inputFormat, filePath, FileProcessingMode.PROCESS_ONCE, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the contents of the user-specified &#123;<span class="doctag">@code</span> filePath&#125; based on the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileInputFormat&#125;. Depending on the provided &#123;<span class="doctag">@link</span> FileProcessingMode&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;See &#123;<span class="doctag">@link</span> #readFile(FileInputFormat, String, FileProcessingMode, long)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFormat The input format used to create the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watchType The mode in which the source should operate, i.e. monitor path and react to</span></span><br><span class="line"><span class="comment">     *     new data, or process once and exit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval In the case of periodic path monitoring, this specifies the interval (in</span></span><br><span class="line"><span class="comment">     *     millis) between consecutive path scans</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filter The files to be excluded from the processing</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data read from the given file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> FileInputFormat#setFilesFilter(FilePathFilter)&#125; to set a filter and</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@link</span> StreamExecutionEnvironment#readFile(FileInputFormat, String, FileProcessingMode,</span></span><br><span class="line"><span class="comment">     *     long)&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">readFile</span><span class="params">(</span></span><br><span class="line"><span class="params">            FileInputFormat&lt;OUT&gt; inputFormat,</span></span><br><span class="line"><span class="params">            String filePath,</span></span><br><span class="line"><span class="params">            FileProcessingMode watchType,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> interval,</span></span><br><span class="line"><span class="params">            FilePathFilter filter)</span> &#123;</span><br><span class="line">        inputFormat.setFilesFilter(filter);</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;OUT&gt; typeInformation;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            typeInformation = TypeExtractor.getInputFormatTypes(inputFormat);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidProgramException</span>(</span><br><span class="line">                    <span class="string">&quot;The type returned by the input format could not be &quot;</span></span><br><span class="line">                            + <span class="string">&quot;automatically determined. Please specify the TypeInformation of the produced type &quot;</span></span><br><span class="line">                            + <span class="string">&quot;explicitly by using the &#x27;createInput(InputFormat, TypeInformation)&#x27; method instead.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readFile(inputFormat, filePath, watchType, interval, typeInformation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the contents of the user-specified &#123;<span class="doctag">@code</span> filePath&#125; based on the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileInputFormat&#125;. Depending on the provided &#123;<span class="doctag">@link</span> FileProcessingMode&#125;, the source may</span></span><br><span class="line"><span class="comment">     * periodically monitor (every &#123;<span class="doctag">@code</span> interval&#125; ms) the path for new data (&#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileProcessingMode#PROCESS_CONTINUOUSLY&#125;), or process once the data currently in the path and</span></span><br><span class="line"><span class="comment">     * exit (&#123;<span class="doctag">@link</span> FileProcessingMode#PROCESS_ONCE&#125;). In addition, if the path contains files not</span></span><br><span class="line"><span class="comment">     * to be processed, the user can specify a custom &#123;<span class="doctag">@link</span> FilePathFilter&#125;. As a default</span></span><br><span class="line"><span class="comment">     * implementation you can use &#123;<span class="doctag">@link</span> FilePathFilter#createDefaultFilter()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Since all data streams need specific information about their types, this method needs to</span></span><br><span class="line"><span class="comment">     * determine the type of the data produced by the input format. It will attempt to determine the</span></span><br><span class="line"><span class="comment">     * data type by reflection, unless the input format implements the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.java.typeutils.ResultTypeQueryable&#125; interface. In the latter case, this</span></span><br><span class="line"><span class="comment">     * method will invoke the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.java.typeutils.ResultTypeQueryable#getProducedType()&#125; method to</span></span><br><span class="line"><span class="comment">     * determine data type produced by the input format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; If the &#123;<span class="doctag">@code</span> watchType&#125; is set to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileProcessingMode#PROCESS_ONCE&#125;, the source monitors the path &lt;b&gt;once&lt;/b&gt;, creates the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards</span></span><br><span class="line"><span class="comment">     * them to the downstream readers to read the actual data, and exits, without waiting for the</span></span><br><span class="line"><span class="comment">     * readers to finish reading. This implies that no more checkpoint barriers are going to be</span></span><br><span class="line"><span class="comment">     * forwarded after the source exits, thus having no checkpoints after that point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFormat The input format used to create the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watchType The mode in which the source should operate, i.e. monitor path and react to</span></span><br><span class="line"><span class="comment">     *     new data, or process once and exit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval In the case of periodic path monitoring, this specifies the interval (in</span></span><br><span class="line"><span class="comment">     *     millis) between consecutive path scans</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data read from the given file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">readFile</span><span class="params">(</span></span><br><span class="line"><span class="params">            FileInputFormat&lt;OUT&gt; inputFormat,</span></span><br><span class="line"><span class="params">            String filePath,</span></span><br><span class="line"><span class="params">            FileProcessingMode watchType,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> interval)</span> &#123;</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;OUT&gt; typeInformation;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            typeInformation = TypeExtractor.getInputFormatTypes(inputFormat);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidProgramException</span>(</span><br><span class="line">                    <span class="string">&quot;The type returned by the input format could not be &quot;</span></span><br><span class="line">                            + <span class="string">&quot;automatically determined. Please specify the TypeInformation of the produced type &quot;</span></span><br><span class="line">                            + <span class="string">&quot;explicitly by using the &#x27;createInput(InputFormat, TypeInformation)&#x27; method instead.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readFile(inputFormat, filePath, watchType, interval, typeInformation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a data stream that contains the contents of file created while system watches the</span></span><br><span class="line"><span class="comment">     * given path. The file will be read with the system&#x27;s default character set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path/&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intervalMillis The interval of file watching in milliseconds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watchType The watch type of file stream. When watchType is &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     org.apache.flink.streaming.api.functions.source.FileMonitoringFunction.WatchType#ONLY_NEW_FILES&#125;,</span></span><br><span class="line"><span class="comment">     *     the system processes only new files. &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     org.apache.flink.streaming.api.functions.source.FileMonitoringFunction.WatchType#REPROCESS_WITH_APPENDED&#125;</span></span><br><span class="line"><span class="comment">     *     means that the system re-processes all contents of appended file. &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     org.apache.flink.streaming.api.functions.source.FileMonitoringFunction.WatchType#PROCESS_ONLY_APPENDED&#125;</span></span><br><span class="line"><span class="comment">     *     means that the system processes only appended contents of files.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The DataStream containing the given directory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #readFile(FileInputFormat, String, FileProcessingMode, long)&#125; instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataStream&lt;String&gt; <span class="title function_">readFileStream</span><span class="params">(</span></span><br><span class="line"><span class="params">            String filePath, <span class="type">long</span> intervalMillis, FileMonitoringFunction.WatchType watchType)</span> &#123;</span><br><span class="line">        DataStream&lt;Tuple3&lt;String, Long, Long&gt;&gt; source =</span><br><span class="line">                addSource(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">FileMonitoringFunction</span>(filePath, intervalMillis, watchType),</span><br><span class="line">                        <span class="string">&quot;Read File Stream source&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> source.flatMap(<span class="keyword">new</span> <span class="title class_">FileReadFunction</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the contents of the user-specified &#123;<span class="doctag">@code</span> filePath&#125; based on the given &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileInputFormat&#125;. Depending on the provided &#123;<span class="doctag">@link</span> FileProcessingMode&#125;, the source may</span></span><br><span class="line"><span class="comment">     * periodically monitor (every &#123;<span class="doctag">@code</span> interval&#125; ms) the path for new data (&#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileProcessingMode#PROCESS_CONTINUOUSLY&#125;), or process once the data currently in the path and</span></span><br><span class="line"><span class="comment">     * exit (&#123;<span class="doctag">@link</span> FileProcessingMode#PROCESS_ONCE&#125;). In addition, if the path contains files not</span></span><br><span class="line"><span class="comment">     * to be processed, the user can specify a custom &#123;<span class="doctag">@link</span> FilePathFilter&#125;. As a default</span></span><br><span class="line"><span class="comment">     * implementation you can use &#123;<span class="doctag">@link</span> FilePathFilter#createDefaultFilter()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; If the &#123;<span class="doctag">@code</span> watchType&#125; is set to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * FileProcessingMode#PROCESS_ONCE&#125;, the source monitors the path &lt;b&gt;once&lt;/b&gt;, creates the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards</span></span><br><span class="line"><span class="comment">     * them to the downstream readers to read the actual data, and exits, without waiting for the</span></span><br><span class="line"><span class="comment">     * readers to finish reading. This implies that no more checkpoint barriers are going to be</span></span><br><span class="line"><span class="comment">     * forwarded after the source exits, thus having no checkpoints after that point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFormat The input format used to create the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g., &quot;file:///some/local/file&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/file/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watchType The mode in which the source should operate, i.e. monitor path and react to</span></span><br><span class="line"><span class="comment">     *     new data, or process once and exit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInformation Information on the type of the elements in the output stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval In the case of periodic path monitoring, this specifies the interval (in</span></span><br><span class="line"><span class="comment">     *     millis) between consecutive path scans</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data read from the given file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">readFile</span><span class="params">(</span></span><br><span class="line"><span class="params">            FileInputFormat&lt;OUT&gt; inputFormat,</span></span><br><span class="line"><span class="params">            String filePath,</span></span><br><span class="line"><span class="params">            FileProcessingMode watchType,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> interval,</span></span><br><span class="line"><span class="params">            TypeInformation&lt;OUT&gt; typeInformation)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Preconditions.checkNotNull(inputFormat, <span class="string">&quot;InputFormat must not be null.&quot;</span>);</span><br><span class="line">        Preconditions.checkArgument(</span><br><span class="line">                !StringUtils.isNullOrWhitespaceOnly(filePath),</span><br><span class="line">                <span class="string">&quot;The file path must not be null or blank.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        inputFormat.setFilePath(filePath);</span><br><span class="line">        <span class="keyword">return</span> createFileInput(</span><br><span class="line">                inputFormat, typeInformation, <span class="string">&quot;Custom File Source&quot;</span>, watchType, interval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains the strings received infinitely from a socket.</span></span><br><span class="line"><span class="comment">     * Received strings are decoded by the system&#x27;s default character set. On the termination of the</span></span><br><span class="line"><span class="comment">     * socket server connection retries can be initiated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Let us note that the socket itself does not report on abort and as a consequence retries</span></span><br><span class="line"><span class="comment">     * are only initiated when the socket was gracefully terminated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hostname The host name which a server socket binds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port number which a server socket binds. A port number of 0 means that the</span></span><br><span class="line"><span class="comment">     *     port number is automatically allocated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delimiter A character which splits received strings into records</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxRetry The maximal retry interval in seconds while the program waits for a socket</span></span><br><span class="line"><span class="comment">     *     that is temporarily down. Reconnection is initiated every second. A number of 0 means</span></span><br><span class="line"><span class="comment">     *     that the reader is immediately terminated, while a negative value ensures retrying</span></span><br><span class="line"><span class="comment">     *     forever.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream containing the strings received from the socket</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #socketTextStream(String, int, String, long)&#125; instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">socketTextStream</span><span class="params">(</span></span><br><span class="line"><span class="params">            String hostname, <span class="type">int</span> port, <span class="type">char</span> delimiter, <span class="type">long</span> maxRetry)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> socketTextStream(hostname, port, String.valueOf(delimiter), maxRetry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains the strings received infinitely from a socket.</span></span><br><span class="line"><span class="comment">     * Received strings are decoded by the system&#x27;s default character set. On the termination of the</span></span><br><span class="line"><span class="comment">     * socket server connection retries can be initiated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Let us note that the socket itself does not report on abort and as a consequence retries</span></span><br><span class="line"><span class="comment">     * are only initiated when the socket was gracefully terminated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hostname The host name which a server socket binds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port number which a server socket binds. A port number of 0 means that the</span></span><br><span class="line"><span class="comment">     *     port number is automatically allocated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delimiter A string which splits received strings into records</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxRetry The maximal retry interval in seconds while the program waits for a socket</span></span><br><span class="line"><span class="comment">     *     that is temporarily down. Reconnection is initiated every second. A number of 0 means</span></span><br><span class="line"><span class="comment">     *     that the reader is immediately terminated, while a negative value ensures retrying</span></span><br><span class="line"><span class="comment">     *     forever.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream containing the strings received from the socket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">socketTextStream</span><span class="params">(</span></span><br><span class="line"><span class="params">            String hostname, <span class="type">int</span> port, String delimiter, <span class="type">long</span> maxRetry)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addSource(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SocketTextStreamFunction</span>(hostname, port, delimiter, maxRetry), <span class="string">&quot;Socket Stream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains the strings received infinitely from a socket.</span></span><br><span class="line"><span class="comment">     * Received strings are decoded by the system&#x27;s default character set. The reader is terminated</span></span><br><span class="line"><span class="comment">     * immediately when the socket is down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hostname The host name which a server socket binds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port number which a server socket binds. A port number of 0 means that the</span></span><br><span class="line"><span class="comment">     *     port number is automatically allocated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delimiter A character which splits received strings into records</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream containing the strings received from the socket</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #socketTextStream(String, int, String)&#125; instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">socketTextStream</span><span class="params">(String hostname, <span class="type">int</span> port, <span class="type">char</span> delimiter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> socketTextStream(hostname, port, delimiter, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains the strings received infinitely from a socket.</span></span><br><span class="line"><span class="comment">     * Received strings are decoded by the system&#x27;s default character set. The reader is terminated</span></span><br><span class="line"><span class="comment">     * immediately when the socket is down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hostname The host name which a server socket binds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port number which a server socket binds. A port number of 0 means that the</span></span><br><span class="line"><span class="comment">     *     port number is automatically allocated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delimiter A string which splits received strings into records</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream containing the strings received from the socket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">socketTextStream</span><span class="params">(String hostname, <span class="type">int</span> port, String delimiter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> socketTextStream(hostname, port, delimiter, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new data stream that contains the strings received infinitely from a socket.</span></span><br><span class="line"><span class="comment">     * Received strings are decoded by the system&#x27;s default character set, using&quot;\n&quot; as delimiter.</span></span><br><span class="line"><span class="comment">     * The reader is terminated immediately when the socket is down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hostname The host name which a server socket binds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port number which a server socket binds. A port number of 0 means that the</span></span><br><span class="line"><span class="comment">     *     port number is automatically allocated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A data stream containing the strings received from the socket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title function_">socketTextStream</span><span class="params">(String hostname, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> socketTextStream(hostname, port, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generic method to create an input data stream with &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.common.io.InputFormat&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Since all data streams need specific information about their types, this method needs to</span></span><br><span class="line"><span class="comment">     * determine the type of the data produced by the input format. It will attempt to determine the</span></span><br><span class="line"><span class="comment">     * data type by reflection, unless the input format implements the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.java.typeutils.ResultTypeQueryable&#125; interface. In the latter case, this</span></span><br><span class="line"><span class="comment">     * method will invoke the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.java.typeutils.ResultTypeQueryable#getProducedType()&#125; method to</span></span><br><span class="line"><span class="comment">     * determine data type produced by the input format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; In the case of a &#123;<span class="doctag">@link</span> FileInputFormat&#125;, the source</span></span><br><span class="line"><span class="comment">     * (which executes the &#123;<span class="doctag">@link</span> ContinuousFileMonitoringFunction&#125;) monitors the path, creates the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards</span></span><br><span class="line"><span class="comment">     * them to the downstream readers to read the actual data, and exits, without waiting for the</span></span><br><span class="line"><span class="comment">     * readers to finish reading. This implies that no more checkpoint barriers are going to be</span></span><br><span class="line"><span class="comment">     * forwarded after the source exits, thus having no checkpoints.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFormat The input format used to create the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data created by the input format</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">createInput</span><span class="params">(InputFormat&lt;OUT, ?&gt; inputFormat)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createInput(inputFormat, TypeExtractor.getInputFormatTypes(inputFormat));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generic method to create an input data stream with &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.common.io.InputFormat&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The data stream is typed to the given TypeInformation. This method is intended for input</span></span><br><span class="line"><span class="comment">     * formats where the return type cannot be determined by reflection analysis, and that do not</span></span><br><span class="line"><span class="comment">     * implement the &#123;<span class="doctag">@link</span> org.apache.flink.api.java.typeutils.ResultTypeQueryable&#125; interface.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;NOTES ON CHECKPOINTING: &lt;/b&gt; In the case of a &#123;<span class="doctag">@link</span> FileInputFormat&#125;, the source</span></span><br><span class="line"><span class="comment">     * (which executes the &#123;<span class="doctag">@link</span> ContinuousFileMonitoringFunction&#125;) monitors the path, creates the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.apache.flink.core.fs.FileInputSplit FileInputSplits&#125; to be processed, forwards</span></span><br><span class="line"><span class="comment">     * them to the downstream readers to read the actual data, and exits, without waiting for the</span></span><br><span class="line"><span class="comment">     * readers to finish reading. This implies that no more checkpoint barriers are going to be</span></span><br><span class="line"><span class="comment">     * forwarded after the source exits, thus having no checkpoints.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFormat The input format used to create the data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo The information about the type of the output type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; The type of the returned data stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The data stream that represents the data created by the input format</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">createInput</span><span class="params">(</span></span><br><span class="line"><span class="params">            InputFormat&lt;OUT, ?&gt; inputFormat, TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        DataStreamSource&lt;OUT&gt; source;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inputFormat <span class="keyword">instanceof</span> FileInputFormat) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            FileInputFormat&lt;OUT&gt; format = (FileInputFormat&lt;OUT&gt;) inputFormat;</span><br><span class="line"></span><br><span class="line">            source =</span><br><span class="line">                    createFileInput(</span><br><span class="line">                            format,</span><br><span class="line">                            typeInfo,</span><br><span class="line">                            <span class="string">&quot;Custom File source&quot;</span>,</span><br><span class="line">                            FileProcessingMode.PROCESS_ONCE,</span><br><span class="line">                            -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            source = createInput(inputFormat, typeInfo, <span class="string">&quot;Custom Source&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">createInput</span><span class="params">(</span></span><br><span class="line"><span class="params">            InputFormat&lt;OUT, ?&gt; inputFormat, TypeInformation&lt;OUT&gt; typeInfo, String sourceName)</span> &#123;</span><br><span class="line"></span><br><span class="line">        InputFormatSourceFunction&lt;OUT&gt; function =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InputFormatSourceFunction</span>&lt;&gt;(inputFormat, typeInfo);</span><br><span class="line">        <span class="keyword">return</span> addSource(function, sourceName, typeInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">createFileInput</span><span class="params">(</span></span><br><span class="line"><span class="params">            FileInputFormat&lt;OUT&gt; inputFormat,</span></span><br><span class="line"><span class="params">            TypeInformation&lt;OUT&gt; typeInfo,</span></span><br><span class="line"><span class="params">            String sourceName,</span></span><br><span class="line"><span class="params">            FileProcessingMode monitoringMode,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> interval)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Preconditions.checkNotNull(inputFormat, <span class="string">&quot;Unspecified file input format.&quot;</span>);</span><br><span class="line">        Preconditions.checkNotNull(typeInfo, <span class="string">&quot;Unspecified output type information.&quot;</span>);</span><br><span class="line">        Preconditions.checkNotNull(sourceName, <span class="string">&quot;Unspecified name for the source.&quot;</span>);</span><br><span class="line">        Preconditions.checkNotNull(monitoringMode, <span class="string">&quot;Unspecified monitoring mode.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Preconditions.checkArgument(</span><br><span class="line">                monitoringMode.equals(FileProcessingMode.PROCESS_ONCE)</span><br><span class="line">                        || interval &gt;= ContinuousFileMonitoringFunction.MIN_MONITORING_INTERVAL,</span><br><span class="line">                <span class="string">&quot;The path monitoring interval cannot be less than &quot;</span></span><br><span class="line">                        + ContinuousFileMonitoringFunction.MIN_MONITORING_INTERVAL</span><br><span class="line">                        + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ContinuousFileMonitoringFunction&lt;OUT&gt; monitoringFunction =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ContinuousFileMonitoringFunction</span>&lt;&gt;(</span><br><span class="line">                        inputFormat, monitoringMode, getParallelism(), interval);</span><br><span class="line"></span><br><span class="line">        ContinuousFileReaderOperatorFactory&lt;OUT, TimestampedFileInputSplit&gt; factory =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ContinuousFileReaderOperatorFactory</span>&lt;&gt;(inputFormat);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boundedness</span> <span class="variable">boundedness</span> <span class="operator">=</span></span><br><span class="line">                monitoringMode == FileProcessingMode.PROCESS_ONCE</span><br><span class="line">                        ? Boundedness.BOUNDED</span><br><span class="line">                        : Boundedness.CONTINUOUS_UNBOUNDED;</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;OUT&gt; source =</span><br><span class="line">                addSource(monitoringFunction, sourceName, <span class="literal">null</span>, boundedness)</span><br><span class="line">                        .transform(<span class="string">&quot;Split Reader: &quot;</span> + sourceName, typeInfo, factory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataStreamSource</span>&lt;&gt;(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a Data Source to the streaming topology.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;By default sources have a parallelism of 1. To enable parallel execution, the user defined</span></span><br><span class="line"><span class="comment">     * source should implement &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.streaming.api.functions.source.ParallelSourceFunction&#125; or extend &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.streaming.api.functions.source.RichParallelSourceFunction&#125;. In these cases</span></span><br><span class="line"><span class="comment">     * the resulting source will have the parallelism of the environment. To change this afterwards</span></span><br><span class="line"><span class="comment">     * call &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.datastream.DataStreamSource#setParallelism(int)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function the user defined function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; type of the returned stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data stream constructed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">addSource</span><span class="params">(SourceFunction&lt;OUT&gt; function)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addSource(function, <span class="string">&quot;Custom Source&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a data source with a custom type information thus opening a &#123;<span class="doctag">@link</span> DataStream&#125;. Only in</span></span><br><span class="line"><span class="comment">     * very special cases does the user need to support type information. Otherwise use &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #addSource(org.apache.flink.streaming.api.functions.source.SourceFunction)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function the user defined function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceName Name of the data source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; type of the returned stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data stream constructed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">addSource</span><span class="params">(SourceFunction&lt;OUT&gt; function, String sourceName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addSource(function, sourceName, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ads a data source with a custom type information thus opening a &#123;<span class="doctag">@link</span> DataStream&#125;. Only in</span></span><br><span class="line"><span class="comment">     * very special cases does the user need to support type information. Otherwise use &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #addSource(org.apache.flink.streaming.api.functions.source.SourceFunction)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function the user defined function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; type of the returned stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo the user defined type information for the stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data stream constructed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">addSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            SourceFunction&lt;OUT&gt; function, TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addSource(function, <span class="string">&quot;Custom Source&quot;</span>, typeInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ads a data source with a custom type information thus opening a &#123;<span class="doctag">@link</span> DataStream&#125;. Only in</span></span><br><span class="line"><span class="comment">     * very special cases does the user need to support type information. Otherwise use &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #addSource(org.apache.flink.streaming.api.functions.source.SourceFunction)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function the user defined function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceName Name of the data source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; type of the returned stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo the user defined type information for the stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data stream constructed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">addSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            SourceFunction&lt;OUT&gt; function, String sourceName, TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addSource(function, sourceName, typeInfo, Boundedness.CONTINUOUS_UNBOUNDED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">addSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> SourceFunction&lt;OUT&gt; function,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> String sourceName,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> <span class="keyword">final</span> TypeInformation&lt;OUT&gt; typeInfo,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> Boundedness boundedness)</span> &#123;</span><br><span class="line">        checkNotNull(function);</span><br><span class="line">        checkNotNull(sourceName);</span><br><span class="line">        checkNotNull(boundedness);</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;OUT&gt; resolvedTypeInfo =</span><br><span class="line">                getTypeInfo(function, sourceName, SourceFunction.class, typeInfo);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isParallel</span> <span class="operator">=</span> function <span class="keyword">instanceof</span> ParallelSourceFunction;</span><br><span class="line"></span><br><span class="line">        clean(function);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> StreamSource&lt;OUT, ?&gt; sourceOperator = <span class="keyword">new</span> <span class="title class_">StreamSource</span>&lt;&gt;(function);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataStreamSource</span>&lt;&gt;(</span><br><span class="line">                <span class="built_in">this</span>, resolvedTypeInfo, sourceOperator, isParallel, sourceName, boundedness);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a data &#123;<span class="doctag">@link</span> Source&#125; to the environment to get a &#123;<span class="doctag">@link</span> DataStream&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The result will be either a bounded data stream (that can be processed in a batch way) or</span></span><br><span class="line"><span class="comment">     * an unbounded data stream (that must be processed in a streaming way), based on the</span></span><br><span class="line"><span class="comment">     * boundedness property of the source, as defined by &#123;<span class="doctag">@link</span> Source#getBoundedness()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The result type (that is used to create serializers for the produced data events) will be</span></span><br><span class="line"><span class="comment">     * automatically extracted. This is useful for sources that describe the produced types already</span></span><br><span class="line"><span class="comment">     * in their configuration, to avoid having to declare the type multiple times. For example the</span></span><br><span class="line"><span class="comment">     * file sources and Kafka sources already define the produced byte their</span></span><br><span class="line"><span class="comment">     * parsers/serializers/formats, and can forward that information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source the user defined source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceName Name of the data source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; type of the returned stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data stream constructed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Experimental</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            Source&lt;OUT, ?, ?&gt; source,</span></span><br><span class="line"><span class="params">            WatermarkStrategy&lt;OUT&gt; timestampsAndWatermarks,</span></span><br><span class="line"><span class="params">            String sourceName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fromSource(source, timestampsAndWatermarks, sourceName, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a data &#123;<span class="doctag">@link</span> Source&#125; to the environment to get a &#123;<span class="doctag">@link</span> DataStream&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The result will be either a bounded data stream (that can be processed in a batch way) or</span></span><br><span class="line"><span class="comment">     * an unbounded data stream (that must be processed in a streaming way), based on the</span></span><br><span class="line"><span class="comment">     * boundedness property of the source, as defined by &#123;<span class="doctag">@link</span> Source#getBoundedness()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method takes an explicit type information for the produced data stream, so that</span></span><br><span class="line"><span class="comment">     * callers can define directly what type/serializer will be used for the produced stream. For</span></span><br><span class="line"><span class="comment">     * sources that describe their produced type, the method &#123;<span class="doctag">@link</span> #fromSource(Source,</span></span><br><span class="line"><span class="comment">     * WatermarkStrategy, String)&#125; can be used to avoid specifying the produced type redundantly.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source the user defined source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceName Name of the data source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;OUT&gt; type of the returned stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeInfo the user defined type information for the stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data stream constructed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Experimental</span></span><br><span class="line">    <span class="keyword">public</span> &lt;OUT&gt; DataStreamSource&lt;OUT&gt; <span class="title function_">fromSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            Source&lt;OUT, ?, ?&gt; source,</span></span><br><span class="line"><span class="params">            WatermarkStrategy&lt;OUT&gt; timestampsAndWatermarks,</span></span><br><span class="line"><span class="params">            String sourceName,</span></span><br><span class="line"><span class="params">            TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TypeInformation&lt;OUT&gt; resolvedTypeInfo =</span><br><span class="line">                getTypeInfo(source, sourceName, Source.class, typeInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataStreamSource</span>&lt;&gt;(</span><br><span class="line">                <span class="built_in">this</span>,</span><br><span class="line">                checkNotNull(source, <span class="string">&quot;source&quot;</span>),</span><br><span class="line">                checkNotNull(timestampsAndWatermarks, <span class="string">&quot;timestampsAndWatermarks&quot;</span>),</span><br><span class="line">                checkNotNull(resolvedTypeInfo),</span><br><span class="line">                checkNotNull(sourceName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Triggers the program execution. The environment will execute all parts of the program that</span></span><br><span class="line"><span class="comment">     * have resulted in a &quot;sink&quot; operation. Sink operations are for example printing results or</span></span><br><span class="line"><span class="comment">     * forwarding them to a message queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The program execution will be logged and displayed with a generated default name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The result of the job execution, containing elapsed time and accumulators.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception which occurs during job execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> JobExecutionResult <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> execute(getJobName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Triggers the program execution. The environment will execute all parts of the program that</span></span><br><span class="line"><span class="comment">     * have resulted in a &quot;sink&quot; operation. Sink operations are for example printing results or</span></span><br><span class="line"><span class="comment">     * forwarding them to a message queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The program execution will be logged and displayed with the provided name</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName Desired name of the job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The result of the job execution, containing elapsed time and accumulators.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception which occurs during job execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> JobExecutionResult <span class="title function_">execute</span><span class="params">(String jobName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Preconditions.checkNotNull(jobName, <span class="string">&quot;Streaming Job name should not be null.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> execute(getStreamGraph(jobName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Triggers the program execution. The environment will execute all parts of the program that</span></span><br><span class="line"><span class="comment">     * have resulted in a &quot;sink&quot; operation. Sink operations are for example printing results or</span></span><br><span class="line"><span class="comment">     * forwarding them to a message queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> streamGraph the stream graph representing the transformations</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The result of the job execution, containing elapsed time and accumulators.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception which occurs during job execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> JobExecutionResult <span class="title function_">execute</span><span class="params">(StreamGraph streamGraph)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">JobClient</span> <span class="variable">jobClient</span> <span class="operator">=</span> executeAsync(streamGraph);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> JobExecutionResult jobExecutionResult;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (configuration.getBoolean(DeploymentOptions.ATTACHED)) &#123;</span><br><span class="line">                jobExecutionResult = jobClient.getJobExecutionResult().get();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                jobExecutionResult = <span class="keyword">new</span> <span class="title class_">DetachedJobExecutionResult</span>(jobClient.getJobID());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            jobListeners.forEach(</span><br><span class="line">                    jobListener -&gt; jobListener.onJobExecuted(jobExecutionResult, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> jobExecutionResult;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// get() on the JobExecutionResult Future will throw an ExecutionException. This</span></span><br><span class="line">            <span class="comment">// behaviour was largely not there in Flink versions before the PipelineExecutor</span></span><br><span class="line">            <span class="comment">// refactoring so we should strip that exception.</span></span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">strippedException</span> <span class="operator">=</span> ExceptionUtils.stripExecutionException(t);</span><br><span class="line"></span><br><span class="line">            jobListeners.forEach(</span><br><span class="line">                    jobListener -&gt; &#123;</span><br><span class="line">                        jobListener.onJobExecuted(<span class="literal">null</span>, strippedException);</span><br><span class="line">                    &#125;);</span><br><span class="line">            ExceptionUtils.rethrowException(strippedException);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// never reached, only make javac happy</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register a &#123;<span class="doctag">@link</span> JobListener&#125; in this environment. The &#123;<span class="doctag">@link</span> JobListener&#125; will be notified</span></span><br><span class="line"><span class="comment">     * on specific job status changed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerJobListener</span><span class="params">(JobListener jobListener)</span> &#123;</span><br><span class="line">        checkNotNull(jobListener, <span class="string">&quot;JobListener cannot be null&quot;</span>);</span><br><span class="line">        jobListeners.add(jobListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Clear all registered &#123;<span class="doctag">@link</span> JobListener&#125;s. */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearJobListeners</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jobListeners.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Triggers the program asynchronously. The environment will execute all parts of the program</span></span><br><span class="line"><span class="comment">     * that have resulted in a &quot;sink&quot; operation. Sink operations are for example printing results or</span></span><br><span class="line"><span class="comment">     * forwarding them to a message queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The program execution will be logged and displayed with a generated default name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> JobClient&#125; that can be used to communicate with the submitted job, completed</span></span><br><span class="line"><span class="comment">     *     on submission succeeded.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception which occurs during job execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> JobClient <span class="title function_">executeAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> executeAsync(getJobName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Triggers the program execution asynchronously. The environment will execute all parts of the</span></span><br><span class="line"><span class="comment">     * program that have resulted in a &quot;sink&quot; operation. Sink operations are for example printing</span></span><br><span class="line"><span class="comment">     * results or forwarding them to a message queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The program execution will be logged and displayed with the provided name</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName desired name of the job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> JobClient&#125; that can be used to communicate with the submitted job, completed</span></span><br><span class="line"><span class="comment">     *     on submission succeeded.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception which occurs during job execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> JobClient <span class="title function_">executeAsync</span><span class="params">(String jobName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> executeAsync(getStreamGraph(checkNotNull(jobName)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Triggers the program execution asynchronously. The environment will execute all parts of the</span></span><br><span class="line"><span class="comment">     * program that have resulted in a &quot;sink&quot; operation. Sink operations are for example printing</span></span><br><span class="line"><span class="comment">     * results or forwarding them to a message queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> streamGraph the stream graph representing the transformations</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> JobClient&#125; that can be used to communicate with the submitted job, completed</span></span><br><span class="line"><span class="comment">     *     on submission succeeded.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception which occurs during job execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> JobClient <span class="title function_">executeAsync</span><span class="params">(StreamGraph streamGraph)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        checkNotNull(streamGraph, <span class="string">&quot;StreamGraph cannot be null.&quot;</span>);</span><br><span class="line">        checkNotNull(</span><br><span class="line">                configuration.get(DeploymentOptions.TARGET),</span><br><span class="line">                <span class="string">&quot;No execution.target specified in your configuration file.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">PipelineExecutorFactory</span> <span class="variable">executorFactory</span> <span class="operator">=</span></span><br><span class="line">                executorServiceLoader.getExecutorFactory(configuration);</span><br><span class="line"></span><br><span class="line">        checkNotNull(</span><br><span class="line">                executorFactory,</span><br><span class="line">                <span class="string">&quot;Cannot find compatible factory for specified execution.target (=%s)&quot;</span>,</span><br><span class="line">                configuration.get(DeploymentOptions.TARGET));</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;JobClient&gt; jobClientFuture =</span><br><span class="line">                executorFactory</span><br><span class="line">                        .getExecutor(configuration)</span><br><span class="line">                        .execute(streamGraph, configuration, userClassloader);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">JobClient</span> <span class="variable">jobClient</span> <span class="operator">=</span> jobClientFuture.get();</span><br><span class="line">            jobListeners.forEach(jobListener -&gt; jobListener.onJobSubmitted(jobClient, <span class="literal">null</span>));</span><br><span class="line">            <span class="keyword">return</span> jobClient;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException executionException) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Throwable</span> <span class="variable">strippedException</span> <span class="operator">=</span></span><br><span class="line">                    ExceptionUtils.stripExecutionException(executionException);</span><br><span class="line">            jobListeners.forEach(</span><br><span class="line">                    jobListener -&gt; jobListener.onJobSubmitted(<span class="literal">null</span>, strippedException));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlinkException</span>(</span><br><span class="line">                    String.format(<span class="string">&quot;Failed to execute job &#x27;%s&#x27;.&quot;</span>, streamGraph.getJobName()),</span><br><span class="line">                    strippedException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Getter of the &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.graph.StreamGraph&#125; of the streaming job.</span></span><br><span class="line"><span class="comment">     * This call clears previously registered &#123;<span class="doctag">@link</span> Transformation transformations&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The streamgraph representing the transformations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> StreamGraph <span class="title function_">getStreamGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getStreamGraph(getJobName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Getter of the &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.graph.StreamGraph&#125; of the streaming job.</span></span><br><span class="line"><span class="comment">     * This call clears previously registered &#123;<span class="doctag">@link</span> Transformation transformations&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName Desired name of the job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The streamgraph representing the transformations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> StreamGraph <span class="title function_">getStreamGraph</span><span class="params">(String jobName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getStreamGraph(jobName, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Getter of the &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.graph.StreamGraph StreamGraph&#125; of the</span></span><br><span class="line"><span class="comment">     * streaming job with the option to clear previously registered &#123;<span class="doctag">@link</span> Transformation</span></span><br><span class="line"><span class="comment">     * transformations&#125;. Clearing the transformations allows, for example, to not re-execute the</span></span><br><span class="line"><span class="comment">     * same operations when calling &#123;<span class="doctag">@link</span> #execute()&#125; multiple times.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobName Desired name of the job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clearTransformations Whether or not to clear previously registered transformations</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The streamgraph representing the transformations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> StreamGraph <span class="title function_">getStreamGraph</span><span class="params">(String jobName, <span class="type">boolean</span> clearTransformations)</span> &#123;</span><br><span class="line">        <span class="type">StreamGraph</span> <span class="variable">streamGraph</span> <span class="operator">=</span> getStreamGraphGenerator().setJobName(jobName).generate();</span><br><span class="line">        <span class="keyword">if</span> (clearTransformations) &#123;</span><br><span class="line">            <span class="built_in">this</span>.transformations.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> streamGraph;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StreamGraphGenerator <span class="title function_">getStreamGraphGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (transformations.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    <span class="string">&quot;No operators defined in streaming topology. Cannot execute.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RuntimeExecutionMode</span> <span class="variable">executionMode</span> <span class="operator">=</span> configuration.get(ExecutionOptions.RUNTIME_MODE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StreamGraphGenerator</span>(transformations, config, checkpointCfg, getConfiguration())</span><br><span class="line">                .setRuntimeExecutionMode(executionMode)</span><br><span class="line">                .setStateBackend(defaultStateBackend)</span><br><span class="line">                .setSavepointDir(defaultSavepointDirectory)</span><br><span class="line">                .setChaining(isChainingEnabled)</span><br><span class="line">                .setUserArtifacts(cacheFile)</span><br><span class="line">                .setTimeCharacteristic(timeCharacteristic)</span><br><span class="line">                .setDefaultBufferTimeout(bufferTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates the plan with which the system will execute the program, and returns it as a String</span></span><br><span class="line"><span class="comment">     * using a JSON representation of the execution data flow graph. Note that this needs to be</span></span><br><span class="line"><span class="comment">     * called, before the plan is executed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The execution plan of the program, as a JSON String.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getExecutionPlan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getStreamGraph(getJobName(), <span class="literal">false</span>).getStreamingPlanAsJSON();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &quot;closure-cleaned&quot; version of the given function. Cleans only if closure cleaning is</span></span><br><span class="line"><span class="comment">     * not disabled in the &#123;<span class="doctag">@link</span> org.apache.flink.api.common.ExecutionConfig&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> &lt;F&gt; F <span class="title function_">clean</span><span class="params">(F f)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getConfig().isClosureCleanerEnabled()) &#123;</span><br><span class="line">            ClosureCleaner.clean(f, getConfig().getClosureCleanerLevel(), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ClosureCleaner.ensureSerializable(f);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds an operator to the list of operators that should be executed when calling &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #execute&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;When calling &#123;<span class="doctag">@link</span> #execute()&#125; only the operators that where previously added to the list</span></span><br><span class="line"><span class="comment">     * are executed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This is not meant to be used by users. The API methods that create operators must call</span></span><br><span class="line"><span class="comment">     * this method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Internal</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOperator</span><span class="params">(Transformation&lt;?&gt; transformation)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(transformation, <span class="string">&quot;transformation must not be null.&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.transformations.add(transformation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Factory methods for ExecutionEnvironments</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an execution environment that represents the context in which the program is</span></span><br><span class="line"><span class="comment">     * currently executed. If the program is invoked standalone, this method returns a local</span></span><br><span class="line"><span class="comment">     * execution environment, as returned by &#123;<span class="doctag">@link</span> #createLocalEnvironment()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The execution environment of the context in which the program is executed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title function_">getExecutionEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getExecutionEnvironment(<span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an execution environment that represents the context in which the program is</span></span><br><span class="line"><span class="comment">     * currently executed. If the program is invoked standalone, this method returns a local</span></span><br><span class="line"><span class="comment">     * execution environment, as returned by &#123;<span class="doctag">@link</span> #createLocalEnvironment(Configuration)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;When executed from the command line the given configuration is stacked on top of the</span></span><br><span class="line"><span class="comment">     * global configuration which comes from the &#123;<span class="doctag">@code</span> flink-conf.yaml&#125;, potentially overriding</span></span><br><span class="line"><span class="comment">     * duplicated options.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration The configuration to instantiate the environment with.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The execution environment of the context in which the program is executed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title function_">getExecutionEnvironment</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Utils.resolveFactory(threadLocalContextEnvironmentFactory, contextEnvironmentFactory)</span><br><span class="line">                .map(factory -&gt; factory.createExecutionEnvironment(configuration))</span><br><span class="line">                .orElseGet(() -&gt; StreamExecutionEnvironment.createLocalEnvironment(configuration));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> LocalStreamEnvironment&#125;. The local execution environment will run the</span></span><br><span class="line"><span class="comment">     * program in a multi-threaded fashion in the same JVM as the environment was created in. The</span></span><br><span class="line"><span class="comment">     * default parallelism of the local environment is the number of hardware contexts (CPU cores /</span></span><br><span class="line"><span class="comment">     * threads), unless it was specified differently by &#123;<span class="doctag">@link</span> #setParallelism(int)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A local execution environment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalStreamEnvironment <span class="title function_">createLocalEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createLocalEnvironment(defaultLocalParallelism);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> LocalStreamEnvironment&#125;. The local execution environment will run the</span></span><br><span class="line"><span class="comment">     * program in a multi-threaded fashion in the same JVM as the environment was created in. It</span></span><br><span class="line"><span class="comment">     * will use the parallelism specified in the parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parallelism The parallelism for the local environment.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A local execution environment with the specified parallelism.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalStreamEnvironment <span class="title function_">createLocalEnvironment</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createLocalEnvironment(parallelism, <span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> LocalStreamEnvironment&#125;. The local execution environment will run the</span></span><br><span class="line"><span class="comment">     * program in a multi-threaded fashion in the same JVM as the environment was created in. It</span></span><br><span class="line"><span class="comment">     * will use the parallelism specified in the parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parallelism The parallelism for the local environment.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration Pass a custom configuration into the cluster</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A local execution environment with the specified parallelism.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalStreamEnvironment <span class="title function_">createLocalEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="type">int</span> parallelism, Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">copyOfConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        copyOfConfiguration.addAll(configuration);</span><br><span class="line">        copyOfConfiguration.set(CoreOptions.DEFAULT_PARALLELISM, parallelism);</span><br><span class="line">        <span class="keyword">return</span> createLocalEnvironment(copyOfConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> LocalStreamEnvironment&#125;. The local execution environment will run the</span></span><br><span class="line"><span class="comment">     * program in a multi-threaded fashion in the same JVM as the environment was created in.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration Pass a custom configuration into the cluster</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A local execution environment with the specified parallelism.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalStreamEnvironment <span class="title function_">createLocalEnvironment</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (configuration.getOptional(CoreOptions.DEFAULT_PARALLELISM).isPresent()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalStreamEnvironment</span>(configuration);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Configuration</span> <span class="variable">copyOfConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">            copyOfConfiguration.addAll(configuration);</span><br><span class="line">            copyOfConfiguration.set(CoreOptions.DEFAULT_PARALLELISM, defaultLocalParallelism);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalStreamEnvironment</span>(copyOfConfiguration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> LocalStreamEnvironment&#125; for local program execution that also starts the web</span></span><br><span class="line"><span class="comment">     * monitoring UI.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The local execution environment will run the program in a multi-threaded fashion in the</span></span><br><span class="line"><span class="comment">     * same JVM as the environment was created in. It will use the parallelism specified in the</span></span><br><span class="line"><span class="comment">     * parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the configuration key &#x27;rest.port&#x27; was set in the configuration, that particular port</span></span><br><span class="line"><span class="comment">     * will be used for the web UI. Otherwise, the default port (8081) will be used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title function_">createLocalEnvironmentWithWebUI</span><span class="params">(Configuration conf)</span> &#123;</span><br><span class="line">        checkNotNull(conf, <span class="string">&quot;conf&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!conf.contains(RestOptions.PORT)) &#123;</span><br><span class="line">            <span class="comment">// explicitly set this option so that it&#x27;s not set to 0 later</span></span><br><span class="line">            conf.setInteger(RestOptions.PORT, RestOptions.PORT.defaultValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> createLocalEnvironment(conf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> RemoteStreamEnvironment&#125;. The remote environment sends (parts of) the</span></span><br><span class="line"><span class="comment">     * program to a cluster for execution. Note that all file paths used in the program must be</span></span><br><span class="line"><span class="comment">     * accessible from the cluster. The execution will use no parallelism, unless the parallelism is</span></span><br><span class="line"><span class="comment">     * set explicitly via &#123;<span class="doctag">@link</span> #setParallelism&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host The host name or address of the master (JobManager), where the program should be</span></span><br><span class="line"><span class="comment">     *     executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port of the master (JobManager), where the program should be executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jarFiles The JAR files with code that needs to be shipped to the cluster. If the</span></span><br><span class="line"><span class="comment">     *     program uses user-defined functions, user-defined input formats, or any libraries, those</span></span><br><span class="line"><span class="comment">     *     must be provided in the JAR files.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A remote environment that executes the program on a cluster.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title function_">createRemoteEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">            String host, <span class="type">int</span> port, String... jarFiles)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RemoteStreamEnvironment</span>(host, port, jarFiles);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> RemoteStreamEnvironment&#125;. The remote environment sends (parts of) the</span></span><br><span class="line"><span class="comment">     * program to a cluster for execution. Note that all file paths used in the program must be</span></span><br><span class="line"><span class="comment">     * accessible from the cluster. The execution will use the specified parallelism.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host The host name or address of the master (JobManager), where the program should be</span></span><br><span class="line"><span class="comment">     *     executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port of the master (JobManager), where the program should be executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parallelism The parallelism to use during the execution.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jarFiles The JAR files with code that needs to be shipped to the cluster. If the</span></span><br><span class="line"><span class="comment">     *     program uses user-defined functions, user-defined input formats, or any libraries, those</span></span><br><span class="line"><span class="comment">     *     must be provided in the JAR files.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A remote environment that executes the program on a cluster.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title function_">createRemoteEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">            String host, <span class="type">int</span> port, <span class="type">int</span> parallelism, String... jarFiles)</span> &#123;</span><br><span class="line">        <span class="type">RemoteStreamEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteStreamEnvironment</span>(host, port, jarFiles);</span><br><span class="line">        env.setParallelism(parallelism);</span><br><span class="line">        <span class="keyword">return</span> env;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> RemoteStreamEnvironment&#125;. The remote environment sends (parts of) the</span></span><br><span class="line"><span class="comment">     * program to a cluster for execution. Note that all file paths used in the program must be</span></span><br><span class="line"><span class="comment">     * accessible from the cluster. The execution will use the specified parallelism.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host The host name or address of the master (JobManager), where the program should be</span></span><br><span class="line"><span class="comment">     *     executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port The port of the master (JobManager), where the program should be executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientConfig The configuration used by the client that connects to the remote cluster.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jarFiles The JAR files with code that needs to be shipped to the cluster. If the</span></span><br><span class="line"><span class="comment">     *     program uses user-defined functions, user-defined input formats, or any libraries, those</span></span><br><span class="line"><span class="comment">     *     must be provided in the JAR files.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A remote environment that executes the program on a cluster.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title function_">createRemoteEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">            String host, <span class="type">int</span> port, Configuration clientConfig, String... jarFiles)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RemoteStreamEnvironment</span>(host, port, clientConfig, jarFiles);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the default parallelism that will be used for the local execution environment created by</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #createLocalEnvironment()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The default local parallelism</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDefaultLocalParallelism</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultLocalParallelism;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the default parallelism that will be used for the local execution environment created by</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #createLocalEnvironment()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parallelism The parallelism to use as the default local parallelism.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PublicEvolving</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setDefaultLocalParallelism</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;</span><br><span class="line">        defaultLocalParallelism = parallelism;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Methods to control the context and local environments for execution from packaged programs</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initializeContextEnvironment</span><span class="params">(StreamExecutionEnvironmentFactory ctx)</span> &#123;</span><br><span class="line">        contextEnvironmentFactory = ctx;</span><br><span class="line">        threadLocalContextEnvironmentFactory.set(contextEnvironmentFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resetContextEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line">        contextEnvironmentFactory = <span class="literal">null</span>;</span><br><span class="line">        threadLocalContextEnvironmentFactory.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers a file at the distributed cache under the given name. The file will be accessible</span></span><br><span class="line"><span class="comment">     * from any user-defined function in the (distributed) runtime under a local path. Files may be</span></span><br><span class="line"><span class="comment">     * local files (which will be distributed via BlobServer), or files in a distributed file</span></span><br><span class="line"><span class="comment">     * system. The runtime will copy the files temporarily to a local cache, if needed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RuntimeContext&#125; can be obtained inside</span></span><br><span class="line"><span class="comment">     * UDFs via &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RichFunction#getRuntimeContext()&#125; and</span></span><br><span class="line"><span class="comment">     * provides access &#123;<span class="doctag">@link</span> org.apache.flink.api.common.cache.DistributedCache&#125; via &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.common.functions.RuntimeContext#getDistributedCache()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g. &quot;file:///some/path&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/and/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name The name under which the file is registered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerCachedFile</span><span class="params">(String filePath, String name)</span> &#123;</span><br><span class="line">        registerCachedFile(filePath, name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers a file at the distributed cache under the given name. The file will be accessible</span></span><br><span class="line"><span class="comment">     * from any user-defined function in the (distributed) runtime under a local path. Files may be</span></span><br><span class="line"><span class="comment">     * local files (which will be distributed via BlobServer), or files in a distributed file</span></span><br><span class="line"><span class="comment">     * system. The runtime will copy the files temporarily to a local cache, if needed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RuntimeContext&#125; can be obtained inside</span></span><br><span class="line"><span class="comment">     * UDFs via &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RichFunction#getRuntimeContext()&#125; and</span></span><br><span class="line"><span class="comment">     * provides access &#123;<span class="doctag">@link</span> org.apache.flink.api.common.cache.DistributedCache&#125; via &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.common.functions.RuntimeContext#getDistributedCache()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath The path of the file, as a URI (e.g. &quot;file:///some/path&quot; or</span></span><br><span class="line"><span class="comment">     *     &quot;hdfs://host:port/and/path&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name The name under which the file is registered.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executable flag indicating whether the file should be executable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerCachedFile</span><span class="params">(String filePath, String name, <span class="type">boolean</span> executable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheFile.add(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(</span><br><span class="line">                        name, <span class="keyword">new</span> <span class="title class_">DistributedCache</span>.DistributedCacheEntry(filePath, executable)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Private helpers.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> &lt;OUT, T <span class="keyword">extends</span> <span class="title class_">TypeInformation</span>&lt;OUT&gt;&gt; T <span class="title function_">getTypeInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">            Object source,</span></span><br><span class="line"><span class="params">            String sourceName,</span></span><br><span class="line"><span class="params">            Class&lt;?&gt; baseSourceClass,</span></span><br><span class="line"><span class="params">            TypeInformation&lt;OUT&gt; typeInfo)</span> &#123;</span><br><span class="line">        TypeInformation&lt;OUT&gt; resolvedTypeInfo = typeInfo;</span><br><span class="line">        <span class="keyword">if</span> (resolvedTypeInfo == <span class="literal">null</span> &amp;&amp; source <span class="keyword">instanceof</span> ResultTypeQueryable) &#123;</span><br><span class="line">            resolvedTypeInfo = ((ResultTypeQueryable&lt;OUT&gt;) source).getProducedType();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolvedTypeInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resolvedTypeInfo =</span><br><span class="line">                        TypeExtractor.createTypeInfo(</span><br><span class="line">                                baseSourceClass, source.getClass(), <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InvalidTypesException e) &#123;</span><br><span class="line">                resolvedTypeInfo = (TypeInformation&lt;OUT&gt;) <span class="keyword">new</span> <span class="title class_">MissingTypeInfo</span>(sourceName, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) resolvedTypeInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getJobName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configuration.getString(PipelineOptions.NAME, DEFAULT_JOB_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>test_post</title>
    <url>/2023/12/18/test-post/</url>
    <content><![CDATA[<h1 id="title1"><a href="#title1" class="headerlink" title="title1"></a>title1</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import title</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>tag1</tag>
        <tag>tag2</tag>
        <tag>tag3</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全</title>
    <url>/2024/01/09/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote>
<p><a href="https://www.bilibili.com/video/BV1bu4y1r7JN/?p=1&spm_id_from=pageDriver&vd_source=55460d497036dd635125163b0e99f789">信息安全概述_哔哩哔哩_bilibili</a></p>
</blockquote>
<h2 id="信息安全的定义："><a href="#信息安全的定义：" class="headerlink" title="信息安全的定义："></a>信息安全的定义：</h2><p>信息是用来消除随机不确定性的东西（香农）。信息安全是指信息网络中的硬件、软件及其系统中的数据受到保护，不受偶然的或者恶意的原因而遭受破坏、更改、泄露、否认等，系统连续可靠的运行，信息服务不中断。</p>
<h2 id="信息安全的基本属性"><a href="#信息安全的基本属性" class="headerlink" title="信息安全的基本属性"></a>信息安全的基本属性</h2><ul>
<li>完整性：保证消息的来源、去向、内容真实无误</li>
<li>保密性：保证消息不会被非法泄露扩散</li>
<li>不可否认性：保证消息的发送者和接收者无法否认自己所做过的操作行为等</li>
<li>可用性：保证网络和信息随时可用，运行过程中不出现故障，若遇意外打击尽可能减少损失并尽快恢复正常</li>
<li>可控性：对网络信息的传播及内容具有控制能力的特性</li>
</ul>
<h2 id="信息安全技术"><a href="#信息安全技术" class="headerlink" title="信息安全技术"></a>信息安全技术</h2><h3 id="信息安全发展历程"><a href="#信息安全发展历程" class="headerlink" title="信息安全发展历程"></a>信息安全发展历程</h3><p>通信安全早期：加密报文</p>
<p>计算机安全：安全计算机的操作模型，该模型基于政府概念的各种级别分类信息（一般、秘密、机密、绝密）和各种许可级别</p>
<p>信息安全保障：解决分布网络环现中级别，正确实施主体对课题的访问控制</p>
<h3 id="信息安全威胁"><a href="#信息安全威胁" class="headerlink" title="信息安全威胁"></a>信息安全威胁</h3><p>物理安全威胁：对系统所用设备的威胁，如自然灾害、电源故障</p>
<p>通信链路安全威胁：对通信链路进行干扰，破坏数据的完整性</p>
<p>操作系统安全威胁：操作系统安全是信息系统安全的基础。系统平台最危险的是在系统软件或硬件芯片中植入威胁</p>
<p>应用系统安全威胁：对于网络服务或用户业务系统安全的威胁</p>
<p>管理系统安全威胁：由于人员不慎造成的信息泄露</p>
<p>网络安全威胁：计算机网络的使用对数据造成了新的安全威胁，当内部网络和国际互联网相接使，对内部网络形成严重的安全威胁</p>
<h3 id="信息安全技术-1"><a href="#信息安全技术-1" class="headerlink" title="信息安全技术"></a>信息安全技术</h3><p>信息保密技术：信息保密技术包括信息加密技术和信息隐藏技术</p>
<p>信息认证技术：认证技术主要用于防止对手对系统进行的主动攻击</p>
<p>访问控制技术：访问控制机制是按事先确定的规则防止未经授权的用户或者用户组非法使用系统资源</p>
<p>入侵检测技术：一种网络信息安全新技术，对网络进行检测，提供对内部攻击、外部攻击和误操作的实时监测以及采取响应的防护手段，如记录证据用于跟踪、恢复和断开网络连接。</p>
<p>信息内容安全：信息安全在政治、法律、道德层次上的要求</p>
<blockquote>
<p>问：“什么是入侵检测系统（IDS）和入侵防御系统（IPS）？它们之间有什么区别？”</p>
<p>IDS和IPS都是信息安全技术中用于保护网络免受恶意入侵的工具。IDS被用来监视和分析网络流量，以便及时发现潜在的恶意活动或入侵行为。IPS是在入侵检测的基础上进一步发展而来的，除了检测和检测恶意行为外，还能主动采取阻止和防御措施来应对恶意入侵</p>
</blockquote>
<h2 id="物理安全"><a href="#物理安全" class="headerlink" title="物理安全"></a>物理安全</h2><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><ol>
<li>保证机房环境</li>
<li>选用合适的传输介质</li>
<li>保证供电安全可靠</li>
</ol>
<h3 id="安全技术："><a href="#安全技术：" class="headerlink" title="安全技术："></a>安全技术：</h3><ol>
<li>物理访问控制：防人防物</li>
<li>生物识别技术：指纹</li>
<li>检测和监控技术： </li>
<li>物理隔离技术：内部网不直接或间接的连接公共网</li>
</ol>
<h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><ol>
<li>环境安全管理：防水、防火</li>
<li>设备安全</li>
</ol>
<h2 id="密码学概述"><a href="#密码学概述" class="headerlink" title="密码学概述"></a>密码学概述</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><ul>
<li>消息（Message）：用语言】文字、数字、符号、图像、声音或其组合等方式记载或传递有意义的内容</li>
<li>明文（Plaintext）：未经任何伪装或隐藏技术处理的消息，也是明文本身</li>
<li>加密（Encryption）：利用某些方法或技术对明文进行伪装或者隐藏的过程</li>
<li>密文（Cipher Text）：将密文恢复成原明文的过程或操作,也称为脱密</li>
<li><strong>密码体制</strong>：<strong>明文空间</strong>、<strong>密文空间</strong>、<strong>密钥空间</strong>、<strong>加密算法</strong>、<strong>解密算法</strong></li>
</ul>
<h2 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>使用相同的密钥对消息进行加密&#x2F;解密，系统的保密性主要由密钥的安全性决定，而与算法是否保密无关。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol>
<li>优点：算法公开、计算量小、加密速度快、加密效率高、适合于数据量比较大的加解密</li>
<li>缺点：密钥协商过程中，一旦密钥泄露，别人可以获取到密钥，这样也能对密文进行解密。收发双方所拥有的密钥数量巨大，密钥管理成为双方的负担</li>
<li>算法：DES算法（目前认为不安全）、3DES算法、AES算法</li>
</ol>
<blockquote>
<p>DES密钥长度为56位，有8位为校验码为</p>
</blockquote>
<h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p>加密密钥P和解密密钥S</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>优点：安全性高、算法强度复杂，特别适用于分布式系统中的数据加密</li>
<li>缺点：速度慢，只适合少量数据进行加密</li>
<li>算法：<strong>RSA算法</strong>、DSA算法、DSS算法</li>
</ol>
<h2 id="密钥管理技术"><a href="#密钥管理技术" class="headerlink" title="密钥管理技术"></a>密钥管理技术</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>管理密钥从产生到销毁的过程，包括密钥的产生、存储、分配、保护、更新、吊销和销毁等。</p>
<p>保证密钥的安全基础：限制一个密钥的使用时间、密钥长度</p>
<h3 id="密钥的分类："><a href="#密钥的分类：" class="headerlink" title="密钥的分类："></a>密钥的分类：</h3><ol>
<li>会话密钥：在通信或数据交换中，用来对用户数据进行加密操作的密钥</li>
<li>密钥加密密钥：用于对密钥（会话密钥）进行加密操作的密钥</li>
<li>主密钥：在一对用户之间的长期共享的秘密密钥</li>
</ol>
<p>层次化密钥（对需要使用的密钥进行分类）的优点有两个：1）密码系统的安全性上；2）有利于密码的生成和管理</p>
<h3 id="密钥的协商与分发技术："><a href="#密钥的协商与分发技术：" class="headerlink" title="密钥的协商与分发技术："></a>密钥的协商与分发技术：</h3><ol>
<li>集中式分配方案：利用网络的“密钥管理中心”来集中管理系统中的密钥</li>
<li>分布式分配方案：由同通信方自己协商完成会话密钥的共享工程，不受任何其他方面的限制</li>
</ol>
<h3 id="密钥加换协议"><a href="#密钥加换协议" class="headerlink" title="密钥加换协议"></a>密钥加换协议</h3><p>Diffie-Hellman密钥交换协议</p>
<h2 id="认证技术"><a href="#认证技术" class="headerlink" title="认证技术"></a>认证技术</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>认证：一个实体向另一个实体证明其所声称的身份的过程</p>
<p>标识：代表实体对象（人员、设备、服务）的身份标识</p>
<p>鉴别：利用相关的数字化凭证（口令、电子签名、证书、令牌）对实体所声称的属性进行识别验证的过程</p>
<h3 id="认证类型与认证过程"><a href="#认证类型与认证过程" class="headerlink" title="认证类型与认证过程"></a>认证类型与认证过程</h3><ol>
<li>单向认证：<ol>
<li>基于共享秘密</li>
<li>基于挑战应答</li>
</ol>
</li>
<li>双向认证：<br>验证者对声称者进行单方面鉴别的同时，声称者也对验证者的身份进行确认。</li>
<li>第三方认证：<ol>
<li>口令认证技术：用户A发送消息到服务B -》 B收到后，检查起正确性 -》 B回复A消息</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>信息系统</tag>
      </tags>
  </entry>
  <entry>
    <title>分类算法</title>
    <url>/2024/01/12/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1zN41167xn?p=2&vd_source=55460d497036dd635125163b0e99f789">第一章：决策树原理 1-决策树算法概述_哔哩哔哩_bilibili</a></p>
<img src="/2024/01/12/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112155024963.png" class="" title="image-20240112155024963">

<img src="/2024/01/12/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112155506650.png" class="" title="image-20240112155506650">

<img src="/2024/01/12/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112155630136.png" class="" title="image-20240112155630136">

<img src="/2024/01/12/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112160606246.png" class="" title="image-20240112160606246">

<img src="/2024/01/12/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112160654223.png" class="" title="image-20240112160654223">

<img src="/2024/01/12/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112160704230.png" class="" title="image-20240112160704230">

<img src="/2024/01/12/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112160742713.png" class="" title="image-20240112160742713">

<img src="/2024/01/12/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112161008571.png" class="" title="image-20240112161008571">

<img src="/2024/01/12/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112161305573.png" class="" title="image-20240112161305573">

<p>ID3的问题：如果出现将ID作为特征，那么结果可能是一个ID下一个样本，算出来熵为0，纯度很高，但是ID对于分类是没有用的。</p>
<p>C4.5：使用信息增益率解决ID3的问题。按照ID分类成14个，算出来<code>ID的熵</code>为0，<code>假设原始的信息增益</code>为9，那么ID的信息增益为<code>假设原始的信息增益 - ID的熵 = 9</code>，但是信息增益率会除以一个数，减少这种不正常的信息增益值，这个数就是 $-\frac{1}{14}\log(\frac{1}{14})$ 。</p>
<p>CART：使用GINI系数</p>
]]></content>
      <tags>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论与数理统计笔记</title>
    <url>/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.bilibili.com/video/BV168411Z7pf?p=1&vd_source=55460d497036dd635125163b0e99f789">概率论与数理统计_哔哩哔哩_bilibili</a></p>
</blockquote>
<h2 id="第一章：随机事件及其概率（一）-哔哩哔哩-bilibili"><a href="#第一章：随机事件及其概率（一）-哔哩哔哩-bilibili" class="headerlink" title="第一章：随机事件及其概率（一）_哔哩哔哩_bilibili"></a><a href="https://www.bilibili.com/video/BV168411Z7pf?p=1&vd_source=55460d497036dd635125163b0e99f789">第一章：随机事件及其概率（一）_哔哩哔哩_bilibili</a></h2><img src="/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/image-20240112220605676.png" class="" title="image-20240112220605676">

<img src="/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/image-20240112220649782.png" class="" title="image-20240112220649782">

<img src="/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/image-20240112220749274.png" class="" title="image-20240112220749274">

<img src="/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/image-20240112220958518.png" class="" title="image-20240112220958518">

<img src="/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/image-20240112221102225.png" class="" title="image-20240112221102225">



<h2 id="第一章：随机事件及其概率（二）-哔哩哔哩-bilibili"><a href="#第一章：随机事件及其概率（二）-哔哩哔哩-bilibili" class="headerlink" title="第一章：随机事件及其概率（二）_哔哩哔哩_bilibili"></a><a href="https://www.bilibili.com/video/BV168411Z7pf?p=2&spm_id_from=pageDriver&vd_source=55460d497036dd635125163b0e99f789">第一章：随机事件及其概率（二）_哔哩哔哩_bilibili</a></h2><img src="/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/image-20240112221145977.png" class="" title="image-20240112221145977">



<img src="/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/image-20240112221915963.png" class="" title="image-20240112221915963">

<img src="/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/image-20240112222256673.png" class="" title="image-20240112222256673">



<h2 id="第二章：一维随机变量及其分布（一）-哔哩哔哩-bilibili"><a href="#第二章：一维随机变量及其分布（一）-哔哩哔哩-bilibili" class="headerlink" title="第二章：一维随机变量及其分布（一）_哔哩哔哩_bilibili"></a><a href="https://www.bilibili.com/video/BV168411Z7pf?p=3&spm_id_from=pageDriver&vd_source=55460d497036dd635125163b0e99f789">第二章：一维随机变量及其分布（一）_哔哩哔哩_bilibili</a></h2><img src="/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/image-20240112223517541.png" class="" title="image-20240112223517541">

<img src="/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/image-20240112223751782.png" class="" title="image-20240112223751782">

<img src="/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/image-20240112224206418.png" class="" title="image-20240112224206418">



<img src="/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/image-20240112224904791.png" class="" title="image-20240112224904791">

<img src="/2024/01/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/image-20240112225116855.png" class="" title="image-20240112225116855">











































]]></content>
      <tags>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程入门</title>
    <url>/2023/12/27/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h1><p>维基百科定义：函数式编程是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算是该语言最重要的基础。而且<strong>λ演算</strong>的函数可以接受函数作为输入的参数和输出的返回值。</p>
<h1 id="学习思路"><a href="#学习思路" class="headerlink" title="学习思路"></a>学习思路</h1><ol>
<li>通过<a href="https://docs.scala-lang.org/zh-cn/scala3/book/fp-intro.html">函数式编程 | Scala 3 — Book | Scala Documentation (scala-lang.org)</a> 学习基本的函数式编程思想</li>
<li>通过 <a href="https://www.lumin.tech/articles/lambda-calculus/">何为 λ 演算 (Lambda Calculus) &#x2F;&#x2F; 圆方 (lumin.tech)</a> 理解什么是函数式编程和lambda演算</li>
<li>通过课程 <a href="https://github.com/vasnake/Principles-of-Reactive-Programming?tab=readme-ov-file">vasnake&#x2F;Principles-of-Reactive-Programming: Principles of Reactive Programming, Scala: assignments and other code from Coursera https://class.coursera.org/reactive-002 (github.com)</a> ，<a href="https://www.bilibili.com/video/BV12J41187dY?p=6&vd_source=55460d497036dd635125163b0e99f789">B站视频</a>学习monad</li>
<li><a href="https://blog.cassite.net/2018/10/06/monad-from-scratch/">从零认识 Monad | wkgcass.blogs (cassite.net)</a></li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li>什么是 <code>IO Monad </code> 来处理输入和输出???<br><a href="https://www.adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html#monads">Functors, Applicatives, And Monads In Pictures - adit.io</a></li>
<li>λ 演算中<code>高阶函数</code>、<code>柯里化</code></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><p><a href="https://docs.scala-lang.org/zh-cn/scala3/book/fp-pure-functions.html">纯函数 | Scala 3 — Book | Scala Documentation (scala-lang.org)</a></p>
</li>
<li><p><a href="https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html">深入理解函数式编程（上） - 美团技术团队 (meituan.com)</a></p>
</li>
<li><p><a href="https://www.lumin.tech/articles/lambda-calculus/">何为 λ 演算 (Lambda Calculus) &#x2F;&#x2F; 圆方 (lumin.tech)</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类算法</title>
    <url>/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.bilibili.com/video/BV1ST411w7De?p=1&vd_source=55460d497036dd635125163b0e99f789">第一章：聚类算法概述_哔哩哔哩_bilibili</a></p>
</blockquote>
<h2 id="K-Means算法"><a href="#K-Means算法" class="headerlink" title="K-Means算法"></a><a href="https://www.bilibili.com/video/BV1ST411w7De?p=1&vd_source=55460d497036dd635125163b0e99f789">K-Means算法</a></h2><img src="/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112114110387.png" class="" title="image-20240112114110387">

<img src="/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112114121865.png" class="" title="image-20240112114121865">

<img src="/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112133210593.png" class="" title="image-20240112133210593">

<img src="/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112134642510.png" class="" title="image-20240112134642510"> 

<img src="/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112135534747.png" class="" title="image-20240112135534747">

<p>优点：</p>
<p>简单，快速，适合常规数据集</p>
<p>缺点：</p>
<p>K值难确定性</p>
<p>复杂度与样本呈线性关系</p>
<p>很那发现任意形状的簇</p>
<p>初始值对结果影响非常大，需要进行多次实验</p>
<h2 id="DBSCAN算法"><a href="#DBSCAN算法" class="headerlink" title="DBSCAN算法"></a><a href="https://www.bilibili.com/video/BV1ST411w7De?p=4&spm_id_from=pageDriver&vd_source=55460d497036dd635125163b0e99f789">DBSCAN算法</a></h2><img src="/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112135610983.png" class="" title="image-20240112135610983">

 <img src="/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112140137553.png" class="" title="image-20240112140137553">

<img src="/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112140323186.png" class="" title="image-20240112140323186">

<img src="/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112140359457.png" class="" title="image-20240112140359457">

<img src="/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112141335924.png" class="" title="image-20240112141335924">



<h2 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a><a href="https://www.bilibili.com/video/BV1ST411w7De?p=24&vd_source=55460d497036dd635125163b0e99f789">层次聚类</a></h2><img src="/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112153053875.png" class="" title="image-20240112153053875">

<img src="/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112153224515.png" class="" title="image-20240112153224515">

<img src="/2024/01/12/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20240112153939360.png" class="" title="image-20240112153939360">



































]]></content>
      <tags>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
</search>
